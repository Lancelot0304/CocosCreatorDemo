{"version":3,"sources":["assets/bundles/game_scene/script/GameLayer/GameDefines/GameDefines.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateBase.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateCreate.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateGameOver.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateInlay.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateMachine.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateMatch.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStateMeger.ts","assets/bundles/game_scene/script/GameLayer/State/GameLayerStatePool.ts","assets/bundles/game_scene/script/GameLayer/GameLayer.ts","assets/bundles/game_scene/script/UILayer/GameOverLayer.ts","assets/bundles/game_scene/script/State/GameSceneStateBase.ts","assets/bundles/game_scene/script/State/GameSceneStateCreate.ts","assets/bundles/game_scene/script/State/GameSceneStateMachine.ts","assets/bundles/game_scene/script/State/GameSceneStateOver.ts","assets/bundles/game_scene/script/State/GameSceneStatePlaying.ts","assets/bundles/game_scene/script/State/GameSceneStatePool.ts","assets/bundles/game_scene/script/GameScene.ts","assets/bundles/game_scene/script/GameLayer/GameDefines/MegerPath.ts","assets/bundles/game_scene/script/UILayer/PauseLayer.ts","assets/bundles/game_scene/script/GameLayer/Tile/TileBase.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateBase.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateCheckMatch.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateCreate.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateGameOver.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateInlay.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateMachine.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStateMeger.ts","assets/bundles/game_scene/script/GameLayer/TileMap/State/TileMapStatePool.ts","assets/bundles/game_scene/script/GameLayer/TileMap/TileMap.ts","assets/bundles/game_scene/script/GameLayer/TilePiece/TilePiece.ts","assets/bundles/game_scene/script/GameLayer/Tile/TileSlot.ts","assets/bundles/game_scene/script/GameLayer/Tile/Tile.ts"],"names":[],"mappings":"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A;AACJ;AAEM;AAGN;AAAsC;AAAtC;AAAA;AAEY;AASA;;AAQZ;AAhBW;AACH;AACJ;AACU;AACN;AACA;AACJ;AAGO;AACH;AACJ;AACO;AACH;AACJ;AAjBiB;AADpB;AACoB;AAmBrB;AAnBA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;;ACXrB;AAKA;AAAA;AACI;AACA;AACA;AACA;AACA;AACA;AACJ;AAEA;AAA8C;AAW1C;AAAA;AATQ;AAWJ;AACA;;AACJ;AAZO;AACH;AACJ;AAEO;AAEP;AAQO;AAEP;AACO;AAEP;AACO;AAEP;AACO;AACH;AACJ;AAEJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AAEA;AACA;AACA;AAEA;AAAoD;AAahD;AAAA;AAFQ;;AAIR;AAbc;AACV;AACA;AACI;AACH;AACD;AACA;AACJ;AAQO;AACH;AACJ;AAEO;AAEH;AACI;AACA;AACA;AACJ;AAGA;AACA;AACI;AACA;AACA;AACI;AACA;AACI;AACA;AACH;AACJ;AACD;AACI;AACA;AACI;AACH;AACJ;AACJ;AAED;AACI;AACH;AAAM;AACH;AACH;AACL;AAEQ;AAEJ;AACA;AACA;AACA;AACA;AACI;AACA;AACA;AACA;AACI;AACA;AACI;AACA;AACA;AACI;AACH;AACJ;AACJ;AACJ;AAED;AACA;AACI;AACA;AACH;AACD;AACJ;AAEQ;AACJ;AACI;AACJ;AACA;AACJ;AAEJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AAEA;AAAgD;AAc5C;AAAA;AAHQ;AACA;;AAIR;AAdc;AACV;AACA;AACI;AACH;AACD;AACA;AACJ;AASQ;AACJ;AACA;AACJ;AAEO;AACH;AACA;AACA;AACJ;AAEO;AACH;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AAEO;AACH;AACI;AACA;AACA;AACA;AACI;AACA;AACH;AAAM;AACH;AACA;AACH;AAED;AACI;AACA;AACH;AACJ;AACL;AAEO;AACH;AACJ;AAEO;AACH;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AAGA;AAAkD;AAW9C;AACI;AACJ;AAXc;AACV;AACA;AACI;AACH;AACD;AACA;AACJ;AAMO;AAEP;AAEO;AAEP;AAGJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AAGA;AACA;AAEA;AAA+C;AAW3C;AACI;AACJ;AAXc;AACV;AACA;AACI;AACH;AACD;AACA;AACJ;AAMO;AAEP;AAEO;AACH;AACA;AACA;AACI;AACI;AACA;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACI;AACA;AACH;AACJ;AAED;AACI;AACA;AACA;AACA;AACH;AACJ;AACD;AACJ;AAEO;AACH;AACA;AACA;AACI;AACA;AACI;AACI;AACH;AAAM;AACH;AACA;AACI;AACA;AACI;AACH;AACJ;AACJ;AACJ;AACJ;AAED;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC7EA;AAGA;AAEA;AAAiD;AAK7C;AACI;AACJ;AANc;AACV;AACA;AACJ;AAKO;AACH;AACA;AACA;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AAGA;AACA;AAGA;AAII;AACI;AACA;AACJ;AACJ;AAAA;AAEA;AAII;AACI;AACA;AACJ;AACJ;AAAA;AAGA;AAA+C;AAiB3C;AAAA;AANQ;AACA;AACA;AAES;AACA;;AAGjB;AAjBc;AACV;AACA;AACI;AACH;AACD;AACA;AACJ;AAYO;AACH;AAEJ;AAEO;AACH;AACI;AACA;AACH;AACL;AAEO;AACH;AACJ;AAGQ;AACJ;AACA;AACI;AACA;AACH;AAED;AACA;AACA;AAEA;AACA;AAIA;AACA;AACJ;AAEQ;AACJ;AACA;AACI;AACA;AACA;AACH;AACD;AACJ;AAEQ;AACJ;AACA;AACA;AACA;AACI;AACH;AAED;AACA;AACI;AACA;AACH;AACD;AACI;AACH;AACL;AAEQ;AACJ;AACA;AACA;AACA;AACA;AACA;AAEI;AACA;AACI;AACA;AACA;AACA;AACA;AACH;AACJ;AAAM;AACH;AACH;AAED;AACA;AACA;AACA;AACJ;AAGQ;AACJ;AACA;AACA;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACnJA;AAGA;AAA8C;AAU1C;AACI;AACJ;AATc;AACV;AACI;AACH;AACD;AACJ;AAMO;AAEP;AAde;AAenB;AAjBA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHrB;AACA;AACA;AAMA;AAEA;AACA;AACA;AAKM;AAEN;AAAA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AAGA;AAAqC;AAArC;AAAA;AA2BI;AAKQ;AASA;AAOA;AAQA;AAQA;AAOA;AAQA;AAwEA;AAwCA;;AAqEZ;AApQqB;AAEH;AACV;AACA;AACA;AACI;AACH;AACD;AACI;AACA;AACA;AACH;AACD;AACJ;AAEO;AACH;AACI;AACA;AACA;AACA;AACA;AACH;AACL;AAIO;AACH;AACJ;AAGO;AACH;AACJ;AAEO;AACH;AACJ;AAGO;AACH;AACJ;AACO;AACH;AACJ;AAEO;AACH;AACJ;AACO;AACH;AACJ;AAGO;AACH;AACJ;AACO;AACH;AACJ;AAGO;AACH;AACJ;AACO;AACH;AACJ;AAEO;AACH;AACJ;AACO;AACH;AACJ;AAGO;AACH;AACJ;AACO;AACH;AACJ;AAEQ;AACJ;AACA;AACJ;AAEO;AACH;AACA;AACA;AACI;AACH;AAED;AACA;AACA;AACJ;AAEO;AACH;AACA;AACA;AAEA;AACA;AACA;AACI;AACH;AACD;AACA;AACJ;AAEO;AACH;AACA;AACI;AACH;AAAM;AACH;AACH;AACL;AAEO;AACH;AACA;AACI;AACA;AACA;AACA;AACA;AACA;AACH;AAED;AACI;AACA;AACA;AACA;AACH;AACD;AACJ;AAEO;AACH;AACJ;AAGO;AACH;AACA;AACA;AACA;AACA;AACA;AAEJ;AAEO;AACH;AACA;AACA;AACI;AACH;AACD;AACA;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACJ;AAEO;AACH;AACA;AACI;AACA;AACA;AACH;AACD;AACJ;AAGO;AACH;AACA;AACI;AACA;AACA;AACA;AACA;AACA;AACH;AACL;AAEO;AACH;AACA;AACA;AACI;AACH;AACD;AACA;AACJ;AAEO;AACH;AACA;AACJ;AAGO;AACH;AACA;AACI;AACA;AACI;AACH;AACJ;AACD;AACJ;AAEO;AACH;AACA;AACI;AACA;AACH;AACD;AACJ;AAGO;AACH;AACA;AACI;AACA;AACH;AACD;AACJ;AAGO;AACH;AACA;AACJ;AAEO;AACH;AACJ;;AAvOA;AADC;AACuB;AA3BP;AADpB;AACoB;AAoQrB;AApQA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BrB;AACA;AACA;AAEA;AACA;AAEM;AACN;AAII;AAHO;AACA;AAGH;AACA;AACJ;AACJ;AAAA;AARa;AAWb;AAAuC;AAAvC;AAAA;AAcI;AAGA;AAEQ;AACA;AAuBA;;AAiEZ;AA1GkB;AACV;AAEA;AACI;AACA;AACA;AACH;AACD;AACJ;AAUO;AACH;AACJ;AACQ;AACJ;AACI;AACA;AACA;AACH;AAAM;AACH;AACA;AACA;AACA;AACA;AACH;AAAM;AACH;AACA;AACA;AACA;AACH;AACL;AAGO;AACH;AACJ;AACQ;AAA6B;AACjC;AACI;AACA;AACA;AACH;AAAM;AACH;AACA;AACA;AACA;AAEA;AACA;AAEA;AACI;AACA;AACA;AAEA;AACA;AACA;AACH;AAAM;AACH;AACA;AACH;AACJ;AACL;AAGO;AACH;AACA;AACJ;AAEO;AACH;AACA;AACA;AACA;AACJ;AACO;AACH;AACA;AACJ;AAEO;AACH;AACJ;AAEO;AACH;AACA;AACI;AACH;AAAM;AACH;AACA;AACH;AAAM;AACN;AACD;AACJ;AA7FA;AADC;AACkB;AAGnB;AADC;AACkB;AAjBF;AADpB;AACoB;AA4GrB;AA5GA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBrB;AACA;AAEA;AAEM;AAEN;AAAsC;AAAtC;;AAgBA;AAdkB;AACV;AAEA;AACI;AACA;AACA;AACH;AACD;AACJ;AAEU;AACN;AACJ;AAfiB;AADpB;AACoB;AAgBrB;AAhBA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPrB;AACA;AACA;AAEA;AAEM;AAEN;AAAkC;AAAlC;AAAA;AAaI;AAGA;AAcQ;;AA8BZ;AA5DqB;AAEH;AACV;AACA;AACI;AACA;AACA;AACH;AACD;AACJ;AAQA;AAEA;AAEA;AAEA;AAOO;AACH;AACJ;AAEO;AACH;AACA;AAEA;AACA;AACA;AACI;AACH;AACL;AAEU;AACN;AACA;AACJ;AAEO;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;;AAjCA;AAEe;AACA;AAhBf;AADC;AACsB;AAGvB;AADC;AACsB;AAhBN;AADpB;AACoB;AA4DrB;AA5DA;AAAqB","sourcesContent":["\r\nexport default class GameDefines {\r\n\r\n    private static _instance: GameDefines = null;\r\n    public static getInstance(): GameDefines {\r\n        if (this._instance == null) {\r\n            this._instance = new GameDefines();\r\n        }\r\n        return this._instance;\r\n    }\r\n    private constructor() {\r\n\r\n    }\r\n}\r\n","import Message from \"../../../../../scripts/Frameworks/EWS/FSM/Message\";\r\nimport State from \"../../../../../scripts/Frameworks/EWS/FSM/State\";\r\nimport GameLayer from \"../GameLayer\";\r\n\r\nexport enum GameLayerStateType {\r\n    None = 0,\r\n    Create,\r\n    Inlay,\r\n    Match,\r\n    Meger,\r\n    GameOver\r\n}\r\n\r\nexport default class GameLayerStateBase extends State<GameLayer> {\r\n\r\n    private _type: GameLayerStateType = GameLayerStateType.None\r\n    public getType(): GameLayerStateType {\r\n        return this._type;\r\n    }\r\n\r\n    public reset() {\r\n\r\n    }\r\n\r\n    protected constructor(type: GameLayerStateType) {\r\n        super();\r\n        this._type = type;\r\n        this.reset()\r\n    }\r\n\r\n    public enter(onwer: GameLayer): void {\r\n\r\n    }\r\n    public update(onwer: GameLayer, deltaTime: number): void {\r\n\r\n    }\r\n    public exit(onwer: GameLayer): void {\r\n\r\n    }\r\n    public onMessage(message: Message): boolean {\r\n        return false\r\n    }\r\n    public onTouchStart(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n    public onTouchMove(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n    public onTouchEnd(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n    public onTouchCancel(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n\r\n}","import GameLayerStateBase, { GameLayerStateType } from \"./GameLayerStateBase\";\r\nimport GameLayerStatePool from \"./GameLayerStatePool\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport TileMap from \"../TileMap/TileMap\";\r\nimport TilePiece, { TilePieceInfo } from \"../TilePiece/TilePiece\";\r\nimport GameLayerStateInlay from \"./GameLayerStateInlay\";\r\n\r\nexport default class GameLayerStateCreate extends GameLayerStateBase {\r\n    public static create(): GameLayerStateCreate {\r\n        let instance = GameLayerStatePool.getInstance().getState(GameLayerStateType.Create) as GameLayerStateCreate\r\n        if (!instance) {\r\n            instance = new GameLayerStateCreate();\r\n        }\r\n        instance.init()\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(GameLayerStateType.Create);\r\n    }\r\n\r\n    private init() {\r\n\r\n    }\r\n\r\n    public enter(onwer: GameLayer): void {\r\n        this.createTileMap(onwer);\r\n        this.createTilePiece(onwer);\r\n        onwer.setCurrentState(GameLayerStateInlay.create())\r\n    }\r\n\r\n    private createTileMap(onwer: GameLayer) {\r\n        let tileMap = TileMap.create(onwer);\r\n        onwer.setTileMap(tileMap);\r\n        tileMap.init(onwer);\r\n    }\r\n\r\n    private createTilePiece(onwer: GameLayer) {\r\n        let tilePiece = TilePiece.create(onwer, new TilePieceInfo([1], 0));\r\n        onwer.setTilePiece(tilePiece);\r\n    }\r\n\r\n}\r\n","import GameLayerStateBase, { GameLayerStateType } from \"./GameLayerStateBase\";\r\nimport GameLayerStatePool from \"./GameLayerStatePool\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport TileMapStateGameOver from \"../TileMap/State/TileMapStateGameOver\";\r\n\r\nexport default class GameLayerStateGameOver extends GameLayerStateBase {\r\n    public static create(): GameLayerStateGameOver {\r\n        let instance = GameLayerStatePool.getInstance().getState(GameLayerStateType.GameOver) as GameLayerStateGameOver\r\n        if (!instance) {\r\n            instance = new GameLayerStateGameOver();\r\n        }\r\n        instance.init()\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(GameLayerStateType.GameOver)\r\n    }\r\n\r\n    private init() {\r\n\r\n    }\r\n\r\n    public enter(onwer: GameLayer): void {\r\n        onwer.getTileMap().setCurrentState(TileMapStateGameOver.create())\r\n        if (onwer.getDelegate()) {\r\n            onwer.getDelegate().onGameOver(onwer);\r\n        }\r\n    }\r\n\r\n}\r\n","import GameLayerStateBase, { GameLayerStateType } from \"./GameLayerStateBase\";\r\nimport GameLayerStatePool from \"./GameLayerStatePool\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport { TilePieceInfo } from \"../TilePiece/TilePiece\";\r\nimport GameLayerStateMatch from \"./GameLayerStateMatch\";\r\nimport TileMapStateGameOver from \"../TileMap/State/TileMapStateGameOver\";\r\nimport TileMapStateInlay from \"../TileMap/State/TileMapStateInlay\";\r\nimport GameLayerStateGameOver from \"./GameLayerStateGameOver\";\r\n\r\nexport default class GameLayerStateInlay extends GameLayerStateBase {\r\n    public static create(): GameLayerStateInlay {\r\n        let instance = GameLayerStatePool.getInstance().getState(GameLayerStateType.Inlay) as GameLayerStateInlay\r\n        if (!instance) {\r\n            instance = new GameLayerStateInlay();\r\n        }\r\n        instance.init()\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(GameLayerStateType.Inlay)\r\n    }\r\n\r\n    private init() {\r\n\r\n    }\r\n\r\n    private _touchStartPos: cc.Vec2 = cc.v2(0, 0)\r\n    private _tilePieceMoved: boolean = false;\r\n    public enter(onwer: GameLayer): void {\r\n        onwer.getTileMap().setCurrentState(TileMapStateInlay.create())\r\n        this.resetTilePiece(onwer);\r\n\r\n        if (!onwer.getTileMap().haveEnoughSlotForTilePiece(onwer.getTilePiece())) {\r\n            onwer.getTileMap().setCurrentState(TileMapStateGameOver.create());\r\n            onwer.setCurrentState(GameLayerStateGameOver.create())\r\n        }\r\n    }\r\n\r\n    public onTouchStart(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n        let pos = onwer.getTilePiece().node.parent.convertToNodeSpaceAR(event.getLocation());\r\n        this._touchStartPos = cc.v2(pos.x, pos.y);\r\n        this._tilePieceMoved = false;\r\n        onwer.getTilePiece().node.stopActionByTag(1001);\r\n        onwer.getTilePiece().setPosition(cc.v2(0, 0));\r\n    }\r\n    public onTouchMove(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n        let pos = onwer.getTilePiece().node.parent.convertToNodeSpaceAR(event.getLocation());\r\n        let offset = cc.v2(pos.x, pos.y).sub(this._touchStartPos);\r\n        if (offset.magSqr() > 100) {\r\n            this._tilePieceMoved = true;\r\n        }\r\n        onwer.getTilePiece().setPosition(offset);\r\n\r\n    }\r\n    public onTouchEnd(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n        if (!this._tilePieceMoved) {\r\n            onwer.getTilePiece().rotate()\r\n        } else {\r\n            let updateLogicalPositions = onwer.getTileMap().insertTilePiece(onwer.getTilePiece())\r\n            if (updateLogicalPositions.length > 0) {\r\n                this.hidePiece(onwer);\r\n                onwer.setCurrentState(GameLayerStateMatch.create(updateLogicalPositions));\r\n            } else {\r\n                this.moveTilePieceBack(onwer);\r\n            }\r\n        }\r\n    }\r\n    public onTouchCancel(onwer: GameLayer, event: cc.Event.EventTouch): void {\r\n        this.onTouchEnd(onwer, event);\r\n    }\r\n\r\n    private moveTilePieceBack(onwer: GameLayer) {\r\n        let move = cc.moveTo(0.25, cc.v2(0, 0)).easing(cc.easeOut(2))\r\n        move.setTag(1001);\r\n        onwer.getTilePiece().node.stopActionByTag(1001);\r\n        onwer.getTilePiece().node.runAction(move);\r\n    }\r\n\r\n    private resetTilePiece(onwer: GameLayer) {\r\n\r\n        let random = Math.floor(Math.random() * 21);\r\n\r\n        let levels: number[] = []\r\n        if (random < 6) {\r\n            let level = Math.floor(Math.random() * 6 + 1);\r\n            levels.push(level)\r\n        } else {\r\n            let level1 = Math.floor(Math.random() * 4 + 1);\r\n            let level2 = 0;\r\n            while (1) {\r\n                level2 = Math.floor(Math.random() * 4 + 1);\r\n                if (level2 != level1) {\r\n                    break;\r\n                }\r\n            }\r\n            levels.push(level1)\r\n            levels.push(level2)\r\n        }\r\n        let angleIndex = Math.floor(Math.random() * 6);\r\n        let tilePiece = onwer.getTilePiece();\r\n        tilePiece.node.active = true;\r\n        tilePiece.setTilePieceInfo(new TilePieceInfo(levels, angleIndex))\r\n        tilePiece.setPosition(cc.v2(0, 0));\r\n    }\r\n\r\n    private hidePiece(onwer: GameLayer) {\r\n        onwer.getTilePiece().node.active = false;\r\n    }\r\n\r\n}\r\n","import SimpleStateMachine from \"../../../../../scripts/Frameworks/EWS/FSM/SimpleStateMachine\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport GameLayerStateBase from \"./GameLayerStateBase\";\r\nimport GameLayerStatePool from \"./GameLayerStatePool\";\r\n\r\nexport default class GameLayerStateMachine extends SimpleStateMachine<GameLayer> {\r\n    public static create(onwer): GameLayerStateMachine {\r\n        let instance = new GameLayerStateMachine(onwer);\r\n        return instance;\r\n    }\r\n\r\n    constructor(onwer: GameLayer) {\r\n        super(onwer);\r\n    }\r\n\r\n    public setCurrentState(newState: GameLayerStateBase): void {\r\n        let oldState = this.getCurrentState();\r\n        super.setCurrentState(newState);\r\n        GameLayerStatePool.getInstance().putState(oldState)\r\n    }\r\n\r\n}\r\n","import GameLayerStateBase, { GameLayerStateType } from \"./GameLayerStateBase\";\r\nimport GameLayerStatePool from \"./GameLayerStatePool\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport TileMapStateCheckMatch from \"../TileMap/State/TileMapStateCheckMatch\";\r\n\r\nexport default class GameLayerStateMatch extends GameLayerStateBase {\r\n\r\n    public static create(positions: cc.Vec2[]): GameLayerStateMatch {\r\n        let instance = GameLayerStatePool.getInstance().getState(GameLayerStateType.Match) as GameLayerStateMatch\r\n        if (!instance) {\r\n            instance = new GameLayerStateMatch();\r\n        }\r\n        instance.init(positions)\r\n        return instance;\r\n    }\r\n\r\n    private _updateLogicalPositions: cc.Vec2[] = []\r\n\r\n    constructor() {\r\n        super(GameLayerStateType.Match)\r\n    }\r\n\r\n    private init(positions: cc.Vec2[]) {\r\n        this._updateLogicalPositions = positions;\r\n    }\r\n\r\n    public enter(onwer: GameLayer): void {\r\n        onwer.getTileMap().setCurrentState(TileMapStateCheckMatch.create(this._updateLogicalPositions));\r\n    }\r\n}\r\n","import GameLayerStateBase, { GameLayerStateType } from \"./GameLayerStateBase\";\r\nimport GameLayerStatePool from \"./GameLayerStatePool\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport TileMapStateMeger from \"../TileMap/State/TileMapStateMeger\";\r\nimport MegerPath, { MergePathNode } from \"../GameDefines/MegerPath\";\r\n\r\nexport default class GameLayerStateMeger extends GameLayerStateBase {\r\n    public static create(megerPaths: MegerPath[]): GameLayerStateMeger {\r\n        let instance = GameLayerStatePool.getInstance().getState(GameLayerStateType.Meger) as GameLayerStateMeger\r\n        if (!instance) {\r\n            instance = new GameLayerStateMeger();\r\n        }\r\n        instance.init(megerPaths)\r\n        return instance;\r\n    }\r\n\r\n    private _megerPaths: MegerPath[] = []\r\n\r\n    constructor() {\r\n        super(GameLayerStateType.Meger)\r\n    }\r\n\r\n    private init(megerPaths: MegerPath[]) {\r\n        this._megerPaths = megerPaths;\r\n    }\r\n\r\n    public enter(onwer: GameLayer): void {\r\n        onwer.getTileMap().setCurrentState(TileMapStateMeger.create(this._megerPaths))\r\n    }\r\n\r\n}\r\n","import StatePool from \"../../../../../scripts/Frameworks/EWS/FSM/StatePool\";\r\nimport GameLayer from \"../GameLayer\";\r\n\r\nexport default class GameLayerStatePool extends StatePool<GameLayer> {\r\n\r\n    private static _instance: GameLayerStatePool = null\r\n    public static getInstance(): GameLayerStatePool {\r\n        if (this._instance == null) {\r\n            this._instance = new GameLayerStatePool();\r\n        }\r\n        return this._instance;\r\n    }\r\n    private constructor() {\r\n        super()\r\n    }\r\n\r\n    public test() {\r\n\r\n    }\r\n}\r\n","import TileMap from \"./TileMap/TileMap\";\r\nimport TilePiece from \"./TilePiece/TilePiece\";\r\nimport GameLayerStateMachine from \"./State/GameLayerStateMachine\";\r\nimport GameLayerStateBase from \"./State/GameLayerStateBase\";\r\nimport GameLayerStateCreate from \"./State/GameLayerStateCreate\";\r\nimport { AssetBundleID } from \"../../../../scripts/Defines/Defines\";\r\nimport WorldBase from \"../../../../scripts/Frameworks/EWS/World/WorldBase\";\r\nimport AssetCache from \"../../../../scripts/Frameworks/AssetCache/AssetCache\";\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n\r\nexport interface GameLayerDelegate {\r\n    onGameOver(gameLayer: GameLayer);\r\n}\r\n\r\n@ccclass\r\nexport default class GameLayer extends WorldBase {\r\n\r\n    public static create(): GameLayer {\r\n        let node: cc.Node = null;\r\n        let res = AssetCache.getInstance().getAssetSync(AssetBundleID.GameScene, \"prefab/game_layer/GameLayer\", cc.Prefab);\r\n        if (res) {\r\n            node = cc.instantiate(res as cc.Prefab);\r\n        }\r\n        if (node) {\r\n            node.setPosition(cc.v2(0, 0));\r\n            let component = node.getComponent(GameLayer);\r\n            return component;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @property(cc.Node)\r\n    tileMapRoot: cc.Node = null\r\n\r\n    @property(cc.Node)\r\n    tilePieceRoot: cc.Node = null;\r\n\r\n    private _delegate: GameLayerDelegate = null;\r\n    public getDelegate(): GameLayerDelegate {\r\n        return this._delegate;\r\n    }\r\n    public setDelegate(delegate: GameLayerDelegate): void {\r\n        this._delegate = delegate;\r\n    }\r\n\r\n    private _tileMap: TileMap = null\r\n    public getTileMap(): TileMap {\r\n        return this._tileMap;\r\n    }\r\n    public setTileMap(tileMap: TileMap): void {\r\n        if (this._tileMap) {\r\n            this._tileMap.node.destroy();\r\n            this._tilePiece = null;\r\n        }\r\n        if (tileMap) {\r\n            this._tileMap = tileMap;\r\n            this._tileMap.setGameLayer(this);\r\n            this.tileMapRoot.addChild(this._tileMap.node);\r\n        }\r\n\r\n    }\r\n\r\n    private _tilePiece: TilePiece = null;\r\n    public getTilePiece(): TilePiece {\r\n        return this._tilePiece;\r\n    }\r\n    public setTilePiece(tilePiece: TilePiece): void {\r\n        if (this._tilePiece) {\r\n            this._tilePiece.node.destroy();\r\n            this._tilePiece = null;\r\n        }\r\n        if (tilePiece) {\r\n            this._tilePiece = tilePiece;\r\n            this.tilePieceRoot.addChild(this._tilePiece.node);\r\n        }\r\n    }\r\n\r\n    private _stateMachine: GameLayerStateMachine = null;\r\n    public getCurrentState(): GameLayerStateBase {\r\n        return this._stateMachine.getCurrentState() as GameLayerStateBase\r\n    }\r\n    public setCurrentState(state: GameLayerStateBase) {\r\n        this._stateMachine.setCurrentState(state);\r\n    }\r\n\r\n    private onTouchStart(event: cc.Event.EventTouch): void {\r\n        let state = this.getCurrentState();\r\n        state.onTouchStart(this, event)\r\n    }\r\n\r\n    private onTouchMove(event: cc.Event.EventTouch): void {\r\n        let state = this.getCurrentState();\r\n        state.onTouchMove(this, event)\r\n    }\r\n\r\n    private onTouchEnd(event: cc.Event.EventTouch): void {\r\n        let state = this.getCurrentState();\r\n        state.onTouchEnd(this, event)\r\n    }\r\n    private onTouchCancel(event: cc.Event.EventTouch): void {\r\n        let state = this.getCurrentState();\r\n        state.onTouchCancel(this, event)\r\n    }\r\n\r\n    public init() {\r\n        if (!this._stateMachine) {\r\n            this._stateMachine = GameLayerStateMachine.create(this);\r\n            this.setCurrentState(GameLayerStateCreate.create())\r\n            this.tilePieceRoot.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this)\r\n            this.tilePieceRoot.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this)\r\n            this.tilePieceRoot.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this)\r\n            this.tilePieceRoot.on(cc.Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this)\r\n        }\r\n    }\r\n\r\n}\r\n","import { AssetBundleID } from \"../../../../scripts/Defines/Defines\";\r\nimport IGame from \"../../../../scripts/Frameworks/IGame/IGame\";\r\nimport LayerBase from \"../../../../scripts/Frameworks/LayerDirector/LayerBase\";\r\nimport LayerDirectorError from \"../../../../scripts/Frameworks/LayerDirector/LayerDirectorError\";\r\nimport LayerEnterParamBase from \"../../../../scripts/Frameworks/LayerDirector/LayerEnterParamBase\";\r\n\r\nexport interface GameOverLayerDelegate {\r\n    backToMain(layer: GameOverLayer);\r\n    replay(layer: GameOverLayer)\r\n}\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n@ccclass\r\nexport default class GameOverLayer extends LayerBase {\r\n\r\n    public static readonly LayerName = \"GameOverLayer\";\r\n    public static show(param?: LayerEnterParamBase,\r\n        completeCallback?: (error: LayerDirectorError, layer: GameOverLayer) => void) {\r\n        IGame.getInstance().addLayerWithPrefab(AssetBundleID.GameScene, \"prefab/ui_layer/GameOverLayer\",\r\n            GameOverLayer.LayerName,\r\n            param,\r\n            (error: LayerDirectorError, layer: LayerBase) => {\r\n                completeCallback && completeCallback(error, layer as GameOverLayer)\r\n            })\r\n    }\r\n\r\n    public getLayerName(): string {\r\n        return GameOverLayer.LayerName;\r\n    }\r\n\r\n    @property(cc.Node)\r\n    backToMainBnt: cc.Node = null\r\n\r\n    @property(cc.Node)\r\n    replayBtn: cc.Node = null\r\n\r\n\r\n    private _delegate: GameOverLayerDelegate = null;\r\n    public getDelegate(): GameOverLayerDelegate {\r\n        return this._delegate;\r\n    }\r\n    public setDelegate(delegate: GameOverLayerDelegate): void {\r\n        this._delegate = delegate;\r\n    }\r\n\r\n    public onLayerLoad(): void {\r\n        this.backToMainBnt.on(cc.Node.EventType.TOUCH_END, this.onBackToMainBtn, this);\r\n        this.replayBtn.on(cc.Node.EventType.TOUCH_END, this.onReplayBtn, this);\r\n\r\n    }\r\n    public onLayerEnable(): void {\r\n\r\n    }\r\n    public onLayerEnter(param: LayerEnterParamBase): void {\r\n\r\n    }\r\n    public onLayerStart(): void {\r\n\r\n    }\r\n    public onLayerUpdate(dt: number): void {\r\n\r\n    }\r\n    public onLayerExit(): void {\r\n\r\n    }\r\n    public onLayerDisable(): void {\r\n\r\n    }\r\n    public onLayerDestroy(): void {\r\n\r\n    }\r\n\r\n    private onBackToMainBtn(event: cc.Event.EventTouch) {\r\n        this.close();\r\n        if (this._delegate) {\r\n            this._delegate.backToMain(this);\r\n        }\r\n    }\r\n\r\n    private onReplayBtn(event: cc.Event.EventTouch) {\r\n        this.close();\r\n        if (this._delegate) {\r\n            this._delegate.replay(this);\r\n        }\r\n    }\r\n\r\n}\r\n","import Message from \"../../../../scripts/Frameworks/EWS/FSM/Message\";\r\nimport State from \"../../../../scripts/Frameworks/EWS/FSM/State\";\r\nimport GameScene from \"../GameScene\";\r\n\r\nexport enum GameSceneStateType {\r\n    None = 0,\r\n    Create,\r\n    Playing,\r\n    GameOver,\r\n}\r\n\r\nexport default class GameSceneStateBase extends State<GameScene> {\r\n\r\n    private _type: GameSceneStateType = GameSceneStateType.None\r\n    public getType(): GameSceneStateType {\r\n        return this._type;\r\n    }\r\n\r\n    public reset() {\r\n\r\n    }\r\n\r\n    protected constructor(type: GameSceneStateType) {\r\n        super();\r\n        this._type = type;\r\n        this.reset()\r\n    }\r\n\r\n    public enter(onwer: GameScene): void {\r\n\r\n    }\r\n    public update(onwer: GameScene, deltaTime: number): void {\r\n\r\n    }\r\n    public exit(onwer: GameScene): void {\r\n\r\n    }\r\n    public onMessage(message: Message): boolean {\r\n        return false\r\n    }\r\n    public onTouchStart(onwer: GameScene, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n    public onTouchMove(onwer: GameScene, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n    public onTouchEnd(onwer: GameScene, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n    public onTouchCancel(onwer: GameScene, event: cc.Event.EventTouch): void {\r\n\r\n    }\r\n\r\n}\r\n","import GameSceneStateBase, { GameSceneStateType } from \"./GameSceneStateBase\";\r\nimport GameScene from \"../GameScene\";\r\nimport GameSceneStatePool from \"./GameSceneStatePool\";\r\nimport GameLayer from \"../GameLayer/GameLayer\";\r\nimport GameSceneStatePlaying from \"./GameSceneStatePlaying\";\r\n\r\nexport default class GameSceneStateCreate extends GameSceneStateBase {\r\n    public static create(): GameSceneStateCreate {\r\n        let instance = GameSceneStatePool.getInstance().getState(GameSceneStateType.Create) as GameSceneStateCreate\r\n        if (!instance) {\r\n            instance = new GameSceneStateCreate();\r\n        }\r\n        instance.init()\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(GameSceneStateType.Create);\r\n    }\r\n\r\n    private init() {\r\n\r\n    }\r\n\r\n    public enter(onwer: GameScene): void {\r\n        this.createGameLayer(onwer);\r\n        onwer.setCurrentState(GameSceneStatePlaying.create())\r\n    }\r\n\r\n    private createGameLayer(onwer: GameScene) {\r\n        let layer = GameLayer.create();\r\n        onwer.setGameLayer(layer);\r\n        layer.init();\r\n    }\r\n\r\n}\r\n","import SimpleStateMachine from \"../../../../scripts/Frameworks/EWS/FSM/SimpleStateMachine\";\r\nimport GameScene from \"../GameScene\";\r\nimport GameSceneStateBase from \"./GameSceneStateBase\";\r\nimport GameSceneStatePool from \"./GameSceneStatePool\";\r\n\r\nexport default class GameSceneStateMachine extends SimpleStateMachine<GameScene> {\r\n    public static create(onwer): GameSceneStateMachine {\r\n        let instance = new GameSceneStateMachine(onwer);\r\n        return instance;\r\n    }\r\n\r\n    constructor(onwer: GameScene) {\r\n        super(onwer);\r\n    }\r\n\r\n    public setCurrentState(newState: GameSceneStateBase): void {\r\n        let oldState = this.getCurrentState();\r\n        super.setCurrentState(newState);\r\n        GameSceneStatePool.getInstance().putState(oldState)\r\n    }\r\n\r\n}\r\n","import GameSceneStateBase, { GameSceneStateType } from \"./GameSceneStateBase\";\r\nimport GameScene from \"../GameScene\";\r\nimport GameSceneStatePool from \"./GameSceneStatePool\";\r\nimport GameOverLayer from \"../UILayer/GameOverLayer\";\r\nimport LayerDirectorError from \"../../../../scripts/Frameworks/LayerDirector/LayerDirectorError\";\r\n\r\nexport default class GameSceneStateOver extends GameSceneStateBase {\r\n    public static create(): GameSceneStateOver {\r\n        let instance = GameSceneStatePool.getInstance().getState(GameSceneStateType.GameOver) as GameSceneStateOver\r\n        if (!instance) {\r\n            instance = new GameSceneStateOver();\r\n        }\r\n        instance.init()\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(GameSceneStateType.GameOver);\r\n    }\r\n\r\n    private init() {\r\n\r\n    }\r\n\r\n    public enter(onwer: GameScene): void {\r\n        GameOverLayer.show(null, (error: LayerDirectorError, layer: GameOverLayer) => {\r\n            layer.setDelegate(onwer);\r\n        })\r\n    }\r\n\r\n}\r\n","import GameSceneStateBase, { GameSceneStateType } from \"./GameSceneStateBase\";\r\nimport GameSceneStatePool from \"./GameSceneStatePool\";\r\n\r\nexport default class GameSceneStatePlaying extends GameSceneStateBase {\r\n    public static create(): GameSceneStatePlaying {\r\n        let instance = GameSceneStatePool.getInstance().getState(GameSceneStateType.Playing) as GameSceneStatePlaying\r\n        if (!instance) {\r\n            instance = new GameSceneStatePlaying();\r\n        }\r\n        instance.init()\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(GameSceneStateType.Playing)\r\n    }\r\n    private init() {\r\n\r\n    }\r\n}\r\n","import StatePool from \"../../../../scripts/Frameworks/EWS/FSM/StatePool\";\r\nimport GameScene from \"../GameScene\";\r\n\r\nexport default class GameSceneStatePool extends StatePool<GameScene> {\r\n\r\n    private static _instance: GameSceneStatePool = null\r\n    public static getInstance(): GameSceneStatePool {\r\n        if (this._instance == null) {\r\n            this._instance = new GameSceneStatePool();\r\n        }\r\n        return this._instance;\r\n    }\r\n    private constructor() {\r\n        super()\r\n    }\r\n\r\n    public test() {\r\n\r\n    }\r\n}\r\n","import PauseLayer from \"./UILayer/PauseLayer\";\r\nimport GameSceneStateMachine from \"./State/GameSceneStateMachine\";\r\nimport GameSceneStateBase from \"./State/GameSceneStateBase\";\r\nimport GameSceneStateCreate from \"./State/GameSceneStateCreate\";\r\nimport GameLayer, { GameLayerDelegate } from \"./GameLayer/GameLayer\";\r\nimport GameSceneStateOver from \"./State/GameSceneStateOver\";\r\nimport GameOverLayer, { GameOverLayerDelegate } from \"./UILayer/GameOverLayer\";\r\nimport SceneBase from \"../../../scripts/Frameworks/SceneDirector/SceneBase\";\r\nimport IGame from \"../../../scripts/Frameworks/IGame/IGame\";\r\nimport LayerDirectorError from \"../../../scripts/Frameworks/LayerDirector/LayerDirectorError\";\r\nimport { AssetBundleID, SceneName } from \"../../../scripts/Defines/Defines\";\r\nimport PreloadBundleInfo from \"../../../scripts/Frameworks/SceneDirector/PreloadAssetInfo\";\r\nimport SceneEnterParamBase from \"../../../scripts/Frameworks/SceneDirector/SceneEnterParamBase\";\r\n\r\n\r\nexport class GameSceneEnterParam extends SceneEnterParamBase {\r\n\r\n}\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n@ccclass\r\nexport default class GameScene extends SceneBase implements GameLayerDelegate, GameOverLayerDelegate {\r\n\r\n    public getSceneName(): string {\r\n        return SceneName.GameScene;\r\n    }\r\n\r\n    @property(cc.Node)\r\n    gameLayerRoot: cc.Node = null;\r\n\r\n    @property(cc.Node)\r\n    pauseBtn: cc.Node = null;\r\n\r\n    private _gameLayer: GameLayer = null\r\n    public getGameLayer(): GameLayer {\r\n        return this._gameLayer;\r\n    }\r\n    public setGameLayer(layer: GameLayer): void {\r\n        if (this._gameLayer) {\r\n            this._gameLayer.node.destroy();\r\n            this._gameLayer = null;\r\n        }\r\n        if (layer) {\r\n            this._gameLayer = layer;\r\n            this._gameLayer.setDelegate(this);\r\n            this.gameLayerRoot.addChild(this._gameLayer.node);\r\n        }\r\n    }\r\n\r\n    private _stateMachine: GameSceneStateMachine = null;\r\n    public getCurrentState(): GameSceneStateBase {\r\n        return this._stateMachine.getCurrentState() as GameSceneStateBase\r\n    }\r\n    public setCurrentState(state: GameSceneStateBase) {\r\n        this._stateMachine.setCurrentState(state);\r\n    }\r\n\r\n    public onSceneLoad(): void { }\r\n    public onSceneEnable(): void { }\r\n    public onSceneEnter(param: SceneEnterParamBase) {\r\n        this._stateMachine = GameSceneStateMachine.create(this);\r\n        this.setCurrentState(GameSceneStateCreate.create())\r\n        this.pauseBtn.on(cc.Node.EventType.TOUCH_END, this.onPauseBtn, this);\r\n    }\r\n    public onSceneStart(): void { }\r\n    public onSceneUpdate(dt: number): void { }\r\n    public onSceneDisable(): void { }\r\n    public onSceneExit(): void { }\r\n    public onSceneDestroy(): void { }\r\n\r\n    public onPauseBtn(event: cc.Event.EventTouch) {\r\n        PauseLayer.show(null, (error: LayerDirectorError, layer: PauseLayer) => {\r\n\r\n        })\r\n    }\r\n\r\n    replay(layer: GameOverLayer) {\r\n        this.setCurrentState(GameSceneStateCreate.create());\r\n    }\r\n\r\n    onReadyForNextPiece(gameLayer: GameLayer) {\r\n\r\n    }\r\n\r\n    onGameOver(gameLayer: GameLayer) {\r\n        this.setCurrentState(GameSceneStateOver.create());\r\n    }\r\n\r\n    backToMain(layer: GameOverLayer) {\r\n        let preloadInfo = PreloadBundleInfo.create();\r\n        preloadInfo.extiBundles = [AssetBundleID.GameScene];\r\n        preloadInfo.enterBundles[AssetBundleID.MainScene] = [];\r\n        IGame.getInstance().replaceSceneWithSwitchScene(preloadInfo, SceneName.MainScene);\r\n    }\r\n}\r\n","export class MergePathNode {\r\n    public readonly fromIndex: number = 0;\r\n    public readonly position: cc.Vec2 = cc.v2(0, 0)\r\n\r\n    constructor(fromIndex: number, position: cc.Vec2) {\r\n        this.fromIndex = fromIndex;\r\n        this.position = position;\r\n    }\r\n\r\n    public static create(fromIndex: number, position: cc.Vec2): MergePathNode {\r\n        let instance = new MergePathNode(fromIndex, position);\r\n        return instance\r\n    }\r\n}\r\n\r\nexport default class MegerPath {\r\n    public readonly nodes: ReadonlyArray<MergePathNode> = [];\r\n    public readonly megerTileLevel: number = 0\r\n    constructor(nodes: MergePathNode[], level: number) {\r\n        this.nodes = nodes;\r\n        this.megerTileLevel = level;\r\n    }\r\n\r\n    public static create(nodes: MergePathNode[], level: number): MegerPath {\r\n        let instance = new MegerPath(nodes, level);\r\n        return instance\r\n    }\r\n\r\n    public findIndex(pos: cc.Vec2): number {\r\n        let index = this.nodes.findIndex((node, index) => {\r\n            return node.position.x == pos.x && node.position.y == pos.y\r\n        })\r\n        return index\r\n    }\r\n\r\n    public isContainPos(pos: cc.Vec2): boolean {\r\n        return this.findIndex(pos) != -1\r\n    }\r\n\r\n    public getMegerPosition(): cc.Vec2 {\r\n        return this.nodes[0].position;\r\n    }\r\n}\r\n","import { AssetBundleID, SceneName } from \"../../../../scripts/Defines/Defines\";\r\nimport IGame from \"../../../../scripts/Frameworks/IGame/IGame\";\r\nimport LayerBase from \"../../../../scripts/Frameworks/LayerDirector/LayerBase\";\r\nimport LayerDirectorError from \"../../../../scripts/Frameworks/LayerDirector/LayerDirectorError\";\r\nimport LayerEnterParamBase from \"../../../../scripts/Frameworks/LayerDirector/LayerEnterParamBase\";\r\nimport PreloadBundleInfo from \"../../../../scripts/Frameworks/SceneDirector/PreloadAssetInfo\";\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n\r\n@ccclass\r\nexport default class PauseLayer extends LayerBase {\r\n\r\n    public static readonly LayerName = \"PauseLayer\";\r\n    public static show(param: LayerEnterParamBase,\r\n        completeCallback: (error: LayerDirectorError, layer: PauseLayer) => void) {\r\n        IGame.getInstance().addLayerWithPrefab(AssetBundleID.GameScene, \"prefab/ui_layer/PauseLayer\",\r\n            PauseLayer.LayerName,\r\n            param,\r\n            (error: LayerDirectorError, layer: LayerBase) => {\r\n                completeCallback && completeCallback(error, layer as PauseLayer)\r\n            })\r\n    }\r\n\r\n    public getLayerName(): string {\r\n        return PauseLayer.LayerName;\r\n    }\r\n\r\n    @property(cc.Node)\r\n    giveUpBtn: cc.Node = null\r\n\r\n    @property(cc.Node)\r\n    resumeBtn: cc.Node = null\r\n\r\n\r\n    public onLayerLoad(): void {\r\n        this.giveUpBtn.on(cc.Node.EventType.TOUCH_END, this.onGiveUpBtn, this);\r\n        this.resumeBtn.on(cc.Node.EventType.TOUCH_END, this.onResumeBtn, this);\r\n\r\n    }\r\n    public onLayerEnable(): void {\r\n\r\n    }\r\n    public onLayerEnter(param: LayerEnterParamBase): void {\r\n\r\n    }\r\n    public onLayerStart(): void {\r\n\r\n    }\r\n    public onLayerUpdate(dt: number): void {\r\n\r\n    }\r\n    public onLayerExit(): void {\r\n\r\n    }\r\n    public onLayerDisable(): void {\r\n\r\n    }\r\n    public onLayerDestroy(): void {\r\n\r\n    }\r\n\r\n    private onGiveUpBtn(event: cc.Event.EventTouch) {\r\n        let preloadInfo = PreloadBundleInfo.create();\r\n        preloadInfo.extiBundles = [AssetBundleID.GameScene];\r\n        preloadInfo.enterBundles[AssetBundleID.MainScene] = [];\r\n        IGame.getInstance().replaceSceneWithSwitchScene(preloadInfo, SceneName.MainScene);\r\n    }\r\n\r\n    private onResumeBtn(event: cc.Event.EventTouch) {\r\n        this.close();\r\n    }\r\n\r\n}\r\n","import EntityBase from \"../../../../../scripts/Frameworks/EWS/Entity/EntityBase\";\r\nimport WorldBase from \"../../../../../scripts/Frameworks/EWS/World/WorldBase\";\r\n\r\nexport enum TileType {\r\n    None,\r\n    Tile,\r\n    Slot,\r\n}\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n\r\n@ccclass\r\nexport default class TileBase extends EntityBase {\r\n\r\n    private _type: TileType = TileType.None;\r\n    public getType(): TileType {\r\n        return this._type;\r\n    }\r\n    protected initWithType(world: WorldBase, type: TileType) {\r\n        super.initEntity(world);\r\n        this._type = type;\r\n    }\r\n\r\n    private _position: cc.Vec2 = cc.v2(0, 0);\r\n    public getLogicalPosition(): cc.Vec2 {\r\n        return this._position;\r\n    }\r\n    public setLogicalPostion(pos: cc.Vec2): void {\r\n        this._position = pos;\r\n    }\r\n\r\n}\r\n","import Message from \"../../../../../../scripts/Frameworks/EWS/FSM/Message\";\r\nimport State from \"../../../../../../scripts/Frameworks/EWS/FSM/State\";\r\nimport TileMap from \"../TileMap\";\r\n\r\n\r\n\r\nexport enum TileMapStateType {\r\n    None = 0,\r\n    Create = 1,\r\n    Inlay,\r\n    CheckMatch,\r\n    Meger,\r\n    GameOver,\r\n}\r\n\r\nexport default class TileMapStateBase extends State<TileMap> {\r\n\r\n    private _type: TileMapStateType = TileMapStateType.None\r\n    public getType(): TileMapStateType {\r\n        return this._type;\r\n    }\r\n\r\n    public reset() {\r\n\r\n    }\r\n\r\n    protected constructor(type: TileMapStateType) {\r\n        super();\r\n        this._type = type;\r\n        this.reset();\r\n    }\r\n\r\n    public enter(onwer: TileMap): void {\r\n\r\n    }\r\n    public update(onwer: TileMap, deltaTime: number): void {\r\n\r\n    }\r\n    public exit(onwer: TileMap): void {\r\n\r\n    }\r\n    public onMessage(message: Message): boolean {\r\n        return false;\r\n    }\r\n\r\n}\r\n","import TileMapStateBase, { TileMapStateType } from \"./TileMapStateBase\";\r\nimport TileMapStatePool from \"./TileMapStatePool\";\r\nimport TileMap from \"../TileMap\";\r\nimport GameLayerStateInlay from \"../../State/GameLayerStateInlay\";\r\nimport MegerPath, { MergePathNode } from \"../../GameDefines/MegerPath\";\r\nimport GameLayerStateMeger from \"../../State/GameLayerStateMeger\";\r\n\r\nexport default class TileMapStateCheckMatch extends TileMapStateBase {\r\n\r\n    public static create(positions: cc.Vec2[]): TileMapStateCheckMatch {\r\n        let instance: TileMapStateCheckMatch = TileMapStatePool.getInstance().getState(TileMapStateType.CheckMatch) as TileMapStateCheckMatch\r\n        if (!instance) {\r\n            instance = new TileMapStateCheckMatch();\r\n        }\r\n        instance.init(positions);\r\n        return instance;\r\n    }\r\n\r\n    private _updateLogicalPositions: cc.Vec2[] = [];\r\n\r\n    constructor() {\r\n        super(TileMapStateType.CheckMatch)\r\n    }\r\n\r\n    public init(positions: cc.Vec2[]) {\r\n        this._updateLogicalPositions = positions;\r\n    }\r\n\r\n    public enter(onwer: TileMap): void {\r\n\r\n        this._updateLogicalPositions.sort((a: cc.Vec2, b: cc.Vec2) => {\r\n            let tileA = onwer.getTileWithLogicalPos(a);\r\n            let tileB = onwer.getTileWithLogicalPos(b);\r\n            return tileA.getLevel() - tileB.getLevel()\r\n        })\r\n\r\n\r\n        let megerPaths: MegerPath[] = []\r\n        for (let index = 0; index < this._updateLogicalPositions.length; index++) {\r\n            let checkPos = this._updateLogicalPositions[index];\r\n            let willMeger = false\r\n            for (let j = 0; j < megerPaths.length; j++) {\r\n                let path = megerPaths[j];\r\n                if (path.isContainPos(checkPos)) {\r\n                    willMeger = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!willMeger) {\r\n                let path = this.getMegerPathFromPos(onwer, checkPos);\r\n                if (path.megerTileLevel > 0) {\r\n                    megerPaths.push(path);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (megerPaths.length > 0) {\r\n            onwer.getGameLayer().setCurrentState(GameLayerStateMeger.create(megerPaths))\r\n        } else {\r\n            onwer.getGameLayer().setCurrentState(GameLayerStateInlay.create())\r\n        }\r\n    }\r\n\r\n    private getMegerPathFromPos(onwer: TileMap, pos: cc.Vec2): MegerPath {\r\n\r\n        let pathNodes: MergePathNode[] = [];\r\n        let checkedPositions: cc.Vec2[] = [];\r\n        pathNodes.push(MergePathNode.create(-1, pos));\r\n        checkedPositions.push(pos);\r\n        for (let i = 0; i < pathNodes.length; i++) {\r\n            let pathNode = pathNodes[i];\r\n            let tile = onwer.getTileWithLogicalPos(pathNode.position);\r\n            let neighbourPositions = onwer.getAllNeighbourPositions(pathNode.position);\r\n            for (let j = 0; j < neighbourPositions.length; j++) {\r\n                let neighbourPos = neighbourPositions[j];\r\n                if (!this.isPostionChecked(checkedPositions, neighbourPos)) {\r\n                    checkedPositions.push(neighbourPos);\r\n                    let neighbourTile = onwer.getTileWithLogicalPos(neighbourPos)\r\n                    if (neighbourTile && tile.getLevel() == neighbourTile.getLevel()) {\r\n                        pathNodes.push(MergePathNode.create(i, neighbourPos));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let level = 0\r\n        if (pathNodes.length >= 3) {\r\n            let tile = onwer.getTileWithLogicalPos(pos);\r\n            level = tile.getLevel() + 1\r\n        }\r\n        return MegerPath.create(pathNodes, level);\r\n    }\r\n\r\n    private isPostionChecked(checkedPositions: cc.Vec2[], pos: cc.Vec2) {\r\n        let index = checkedPositions.findIndex((value: cc.Vec2, index: number) => {\r\n            return value.x == pos.x && value.y == pos.y\r\n        })\r\n        return index != -1\r\n    }\r\n\r\n}\r\n","import TileMap, { TileMapDirection } from \"../TileMap\";\r\nimport TileMapStateBase, { TileMapStateType } from \"./TileMapStateBase\";\r\nimport TileSlot from \"../../Tile/TileSlot\";\r\nimport TileMapStateInlay from \"./TileMapStateInlay\";\r\nimport TileMapStatePool from \"./TileMapStatePool\";\r\n\r\nexport default class TileMapStateCreate extends TileMapStateBase {\r\n\r\n    public static create(mapSize: cc.Size, tileSize: cc.Size): TileMapStateCreate {\r\n        let instance: TileMapStateCreate = TileMapStatePool.getInstance().getState(TileMapStateType.Create) as TileMapStateCreate\r\n        if (!instance) {\r\n            instance = new TileMapStateCreate();\r\n        }\r\n        instance.init(mapSize, tileSize);\r\n        return instance;\r\n    }\r\n\r\n    private _mapSize: cc.Size = cc.size(0, 0);\r\n    private _tileSize: cc.Size = cc.size(0, 0);\r\n\r\n    private constructor() {\r\n        super(TileMapStateType.Create);\r\n    }\r\n\r\n    private init(mapSize: cc.Size, tileSize: cc.Size) {\r\n        this._mapSize = mapSize;\r\n        this._tileSize = tileSize;\r\n    }\r\n\r\n    public enter(onwer: TileMap): void {\r\n        this.initCoordinate(onwer);\r\n        this.initSlots(onwer);\r\n        onwer.setCurrentState(TileMapStateInlay.create())\r\n    }\r\n\r\n    public initCoordinate(onwer: TileMap) {\r\n        let slotRootSize = onwer.getTileRoot().getContentSize();\r\n        let y = (slotRootSize.height - (this._tileSize.height * this._mapSize.height)) * 0.5;\r\n        let x = (slotRootSize.width - (this._tileSize.width * this._mapSize.width)) * 0.5;\r\n        onwer.setTileSize(this._tileSize);\r\n        onwer.setMapSize(this._mapSize);\r\n        onwer.setOrigin(cc.v2(x + this._tileSize.width * 0.5, y + this._tileSize.height * 0.5));\r\n\r\n        let evenRowDirectionToOffsetDict = {}\r\n        evenRowDirectionToOffsetDict[TileMapDirection.Right] = cc.v2(1, 0)\r\n        evenRowDirectionToOffsetDict[TileMapDirection.RightTop] = cc.v2(1, 1)\r\n        evenRowDirectionToOffsetDict[TileMapDirection.LeftTop] = cc.v2(0, 1)\r\n        evenRowDirectionToOffsetDict[TileMapDirection.Left] = cc.v2(-1, 0)\r\n        evenRowDirectionToOffsetDict[TileMapDirection.LeftBottom] = cc.v2(0, -1)\r\n        evenRowDirectionToOffsetDict[TileMapDirection.RightBottom] = cc.v2(1, -1)\r\n        onwer.setEvenRowDirectionToOffsetDict(evenRowDirectionToOffsetDict);\r\n\r\n        let oddRowDirectionToOffsetDict = {}\r\n        oddRowDirectionToOffsetDict[TileMapDirection.Right] = cc.v2(1, 0)\r\n        oddRowDirectionToOffsetDict[TileMapDirection.RightTop] = cc.v2(0, 1)\r\n        oddRowDirectionToOffsetDict[TileMapDirection.LeftTop] = cc.v2(-1, 1)\r\n        oddRowDirectionToOffsetDict[TileMapDirection.Left] = cc.v2(-1, 0)\r\n        oddRowDirectionToOffsetDict[TileMapDirection.LeftBottom] = cc.v2(-1, -1)\r\n        oddRowDirectionToOffsetDict[TileMapDirection.RightBottom] = cc.v2(0, -1)\r\n        onwer.setOddRowDirectionToOffsetDict(oddRowDirectionToOffsetDict);\r\n    }\r\n\r\n    public initSlots(onwer: TileMap) {\r\n        for (let i = 0; i < this._mapSize.height; i++) {\r\n            let delta = Math.abs(Math.floor(i - this.getCenterRow()))\r\n            let startX = 0;\r\n            let endX = this._mapSize.width;\r\n            if (delta % 2 == 0) {\r\n                startX += Math.floor(delta * 0.5)\r\n                endX -= Math.floor(delta * 0.5);\r\n            } else {\r\n                startX += Math.floor(delta * 0.5);\r\n                endX -= Math.ceil(delta * 0.5)\r\n            }\r\n\r\n            for (let j = startX; j < endX; j++) {\r\n                let slot = TileSlot.create(onwer.getWorld());\r\n                onwer.addSlotWithLogicalPos(slot, cc.v2(j, i))\r\n            }\r\n        }\r\n    }\r\n\r\n    public getCenterRow(): number {\r\n        return Math.floor(this._mapSize.height * 0.5);\r\n    }\r\n\r\n    public getCenterColumn(): number {\r\n        return Math.floor(this._mapSize.width * 0.5);\r\n    }\r\n}\r\n","import TileMapStateBase, { TileMapStateType } from \"./TileMapStateBase\";\r\nimport TileMapStatePool from \"./TileMapStatePool\";\r\nimport TileMap from \"../TileMap\";\r\n\r\nexport default class TileMapStateGameOver extends TileMapStateBase {\r\n\r\n    public static create(): TileMapStateGameOver {\r\n        let instance: TileMapStateGameOver = TileMapStatePool.getInstance().getState(TileMapStateType.GameOver) as TileMapStateGameOver\r\n        if (!instance) {\r\n            instance = new TileMapStateGameOver();\r\n        }\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(TileMapStateType.GameOver)\r\n    }\r\n\r\n    public init() {\r\n\r\n    }\r\n\r\n    public enter(onwer: TileMap): void {\r\n\r\n    }\r\n\r\n\r\n}\r\n","import TileMapStateBase, { TileMapStateType } from \"./TileMapStateBase\";\r\nimport TileMap from \"../TileMap\";\r\nimport TilePiece from \"../../TilePiece/TilePiece\";\r\nimport Tile from \"../../Tile/Tile\";\r\nimport TileMapStatePool from \"./TileMapStatePool\";\r\n\r\nexport default class TileMapStateInlay extends TileMapStateBase {\r\n\r\n    public static create(): TileMapStateInlay {\r\n        let instance: TileMapStateInlay = TileMapStatePool.getInstance().getState(TileMapStateType.Inlay) as TileMapStateInlay\r\n        if (!instance) {\r\n            instance = new TileMapStateInlay();\r\n        }\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    constructor() {\r\n        super(TileMapStateType.Inlay)\r\n    }\r\n\r\n    public init() {\r\n\r\n    }\r\n\r\n    public inlayTilePiece(tileMap: TileMap, tilePiece: TilePiece): cc.Vec2[] {\r\n        let logicalPositions: cc.Vec2[] = [];\r\n        let tiles = tilePiece.getTiles();\r\n        if (tiles.length > 0) {\r\n            for (let index = 0; index < tiles.length; index++) {\r\n                let tile = tiles[index];\r\n                let worldPos = tile.node.parent.convertToWorldSpaceAR(tile.getPosition());\r\n                let mapPos = tileMap.getTileRoot().convertToNodeSpaceAR(worldPos);\r\n                let logicalPos = tileMap.getLogicalPosWithPixelPos(cc.v2(mapPos));\r\n                logicalPositions.push(logicalPos)\r\n            }\r\n\r\n            for (let index = 0; index < logicalPositions.length; index++) {\r\n                let pos = logicalPositions[index];\r\n                if (!tileMap.isTileSlotEmptyAtLogicalPos(pos)) {\r\n                    logicalPositions = [];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            for (let index = 0; index < logicalPositions.length; index++) {\r\n                let pos = logicalPositions[index];\r\n                let tile = tiles[index];\r\n                let newTile = Tile.create(tileMap.getWorld(), tile.getLevel());\r\n                tileMap.addTileWithLogicalPos(newTile, pos);\r\n            }\r\n        }\r\n        return logicalPositions;\r\n    }\r\n\r\n    public haveEnoughSlotForTilePiece(tileMap: TileMap, tilePiece: TilePiece): boolean {\r\n        let tilePieceCount: number = tilePiece.getLevels().length;\r\n        let validPostions = tileMap.getAllValidPositions();\r\n        for (let index = 0; index < validPostions.length; index++) {\r\n            let logicalPos = validPostions[index];\r\n            if (tileMap.isTileSlotEmptyAtLogicalPos(logicalPos)) {\r\n                if (tilePieceCount == 1) {\r\n                    return true;\r\n                } else if (tilePieceCount == 2) {\r\n                    let neighbourPostions = tileMap.getAllNeighbourPositions(logicalPos)\r\n                    for (let index = 0; index < neighbourPostions.length; index++) {\r\n                        let checkPos = neighbourPostions[index];\r\n                        if (tileMap.isTileSlotEmptyAtLogicalPos(checkPos)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","import SimpleStateMachine from \"../../../../../../scripts/Frameworks/EWS/FSM/SimpleStateMachine\";\r\nimport TileMap from \"../TileMap\";\r\nimport TileMapStateBase from \"./TileMapStateBase\";\r\nimport TileMapStatePool from \"./TileMapStatePool\";\r\n\r\nexport default class TileMapStateMachine extends SimpleStateMachine<TileMap> {\r\n    public static create(onwer: TileMap): TileMapStateMachine {\r\n        let instance = new TileMapStateMachine(onwer);\r\n        return instance\r\n    }\r\n    constructor(onwer: TileMap) {\r\n        super(onwer);\r\n    }\r\n\r\n    public setCurrentState(newState: TileMapStateBase): void {\r\n        let oldState = this.getCurrentState();\r\n        super.setCurrentState(newState);\r\n        TileMapStatePool.getInstance().putState(oldState)\r\n    }\r\n}\r\n","import TileMapStateBase, { TileMapStateType } from \"./TileMapStateBase\";\r\nimport TileMapStatePool from \"./TileMapStatePool\";\r\nimport TileMap from \"../TileMap\";\r\nimport MegerPath from \"../../GameDefines/MegerPath\";\r\nimport Tile from \"../../Tile/Tile\";\r\nimport GameLayerStateMatch from \"../../State/GameLayerStateMatch\";\r\n\r\n\r\nclass NewTileFinishMegerData {\r\n    public tileMap: TileMap;\r\n    public megerPath: MegerPath;\r\n\r\n    constructor(tileMap: TileMap, megerPath: MegerPath) {\r\n        this.tileMap = tileMap;\r\n        this.megerPath = megerPath;\r\n    }\r\n}\r\n\r\nclass OldTileFinishMegerData {\r\n    public tileMap: TileMap;\r\n    public tile: Tile;\r\n\r\n    constructor(tileMap: TileMap, tile: Tile) {\r\n        this.tileMap = tileMap;\r\n        this.tile = tile;\r\n    }\r\n}\r\n\r\n\r\nexport default class TileMapStateMeger extends TileMapStateBase {\r\n\r\n    public static create(megerPaths: MegerPath[]): TileMapStateMeger {\r\n        let instance: TileMapStateMeger = TileMapStatePool.getInstance().getState(TileMapStateType.Meger) as TileMapStateMeger\r\n        if (!instance) {\r\n            instance = new TileMapStateMeger();\r\n        }\r\n        instance.init(megerPaths);\r\n        return instance;\r\n    }\r\n\r\n    private _megerPaths: MegerPath[] = [];\r\n    private _pendMegerPath: MegerPath[] = []\r\n    private _pendingTiles: Tile[][] = [];\r\n\r\n    private readonly _moveDuration: number = 0.25;\r\n    private readonly _disappearDuration: number = 0.25;\r\n    constructor() {\r\n        super(TileMapStateType.Meger)\r\n    }\r\n\r\n    public init(megerPaths: MegerPath[]) {\r\n        this._megerPaths = megerPaths;\r\n\r\n    }\r\n\r\n    public enter(onwer: TileMap): void {\r\n        for (let index = 0; index < this._megerPaths.length; index++) {\r\n            let path = this._megerPaths[index];\r\n            this.createNewTileMegerAnimation(onwer, path);\r\n        }\r\n    }\r\n\r\n    public exit(onwer: TileMap): void {\r\n        this._megerPaths.length = 0;\r\n    }\r\n\r\n\r\n    private createNewTileMegerAnimation(onwer: TileMap, path: MegerPath) {\r\n        this._pendMegerPath.push(path);\r\n        for (let index = path.nodes.length - 1; index > -1; index--) {\r\n            let nodeIndexes = this.getNodeIndexesWithPathIndex(path, index);\r\n            this.createOldTileMegerAnimation(onwer, path, nodeIndexes)\r\n        }\r\n\r\n        let newTile = Tile.create(onwer.getWorld(), path.megerTileLevel)\r\n        onwer.addTileWithLogicalPos(newTile, path.getMegerPosition())\r\n        newTile.node.scale = 0;\r\n\r\n        let delay = cc.delayTime(this._moveDuration)\r\n        let appear = cc.spawn(\r\n            cc.scaleTo(0.3, 1).easing(cc.easeBackOut()),\r\n            cc.fadeIn(0.3),\r\n        )\r\n        let action = cc.sequence(delay, appear, cc.callFunc(this.newTileFinishMeger, this, new NewTileFinishMegerData(onwer, path)))\r\n        newTile.node.runAction(action);\r\n    }\r\n\r\n    private getNodeIndexesWithPathIndex(path: MegerPath, index: number): number[] {\r\n        let result: number[] = [];\r\n        while (index > -1) {\r\n            let node = path.nodes[index];\r\n            result.push(index);\r\n            index = node.fromIndex;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private newTileFinishMeger(node: cc.Node, data: NewTileFinishMegerData) {\r\n        let tileMap: TileMap = data.tileMap;\r\n        let megerPath: MegerPath = data.megerPath;\r\n        let index = this._pendMegerPath.indexOf(megerPath);\r\n        if (index != -1) {\r\n            this._pendMegerPath.splice(index, 1);\r\n        }\r\n\r\n        let checkPostions: cc.Vec2[] = []\r\n        for (let index = 0; index < this._megerPaths.length; index++) {\r\n            let path = this._megerPaths[index];\r\n            checkPostions.push(path.getMegerPosition())\r\n        }\r\n        if (this._pendingTiles.length <= 0) {\r\n            tileMap.getGameLayer().setCurrentState(GameLayerStateMatch.create(checkPostions))\r\n        }\r\n    }\r\n\r\n    private createOldTileMegerAnimation(onwer: TileMap, path: MegerPath, indexes: number[],) {\r\n        let startNode = path.nodes[indexes[0]];\r\n        let tile = onwer.removeTileWithLogicalPos(startNode.position);\r\n        onwer.addAnimationTileWithLogicalPos(tile, startNode.position);\r\n        this._pendMegerPath.push(path)\r\n        let moveAction: cc.FiniteTimeAction[] = []\r\n        if (indexes.length > 1) {\r\n\r\n            let stepDuration = this._moveDuration / (indexes.length - 1);\r\n            for (let i = 1; i < indexes.length; i++) {\r\n                let nodeIndex = indexes[i];\r\n                let node = path.nodes[nodeIndex];\r\n                let pixelPos = onwer.getPixelPosWithLogicalPos(node.position)\r\n                let move = cc.moveTo(stepDuration, pixelPos);\r\n                moveAction.push(move);\r\n            }\r\n        } else {\r\n            moveAction.push(cc.delayTime(this._moveDuration))\r\n        }\r\n\r\n        moveAction.push(cc.spawn(cc.fadeOut(this._disappearDuration).easing(cc.easeOut(2)), cc.scaleTo(this._disappearDuration, 0)))\r\n        moveAction.push(cc.callFunc(this.oldTileFinishMerge, this, new OldTileFinishMegerData(onwer, tile)))\r\n        let action = cc.sequence(moveAction)\r\n        tile.node.runAction(action);\r\n    }\r\n\r\n\r\n    private oldTileFinishMerge(node: cc.Node, data: OldTileFinishMegerData) {\r\n        let tileMap: TileMap = data.tileMap;\r\n        let tile = data.tile;\r\n        tileMap.removeAnimationTile(tile);\r\n    }\r\n}\r\n","import StatePool from \"../../../../../../scripts/Frameworks/EWS/FSM/StatePool\";\r\nimport TileMap from \"../TileMap\";\r\n\r\nexport default class TileMapStatePool extends StatePool<TileMap> {\r\n\r\n    private static _instance: TileMapStatePool = null\r\n    public static getInstance(): TileMapStatePool {\r\n        if (this._instance == null) {\r\n            this._instance = new TileMapStatePool();\r\n        }\r\n        return this._instance;\r\n    }\r\n\r\n    private constructor() {\r\n        super()\r\n    }\r\n\r\n    public test() {\r\n\r\n    }\r\n}\r\n","import TileMapStateMachine from \"./State/TileMapStateMachine\";\r\nimport TileMapStateCreate from \"./State/TileMapStateCreate\";\r\nimport TileMapStateBase, { TileMapStateType } from \"./State/TileMapStateBase\";\r\nimport TileSlot from \"../Tile/TileSlot\";\r\nimport Tile from \"../Tile/Tile\";\r\nimport TilePiece from \"../TilePiece/TilePiece\";\r\nimport TileMapStateInlay from \"./State/TileMapStateInlay\";\r\nimport GameLayer from \"../GameLayer\";\r\nimport EntityBase from \"../../../../../scripts/Frameworks/EWS/Entity/EntityBase\";\r\nimport WorldBase from \"../../../../../scripts/Frameworks/EWS/World/WorldBase\";\r\nimport AssetCache from \"../../../../../scripts/Frameworks/AssetCache/AssetCache\";\r\nimport { AssetBundleID } from \"../../../../../scripts/Defines/Defines\";\r\nimport GameMath from \"../../../../../scripts/Frameworks/Utils/GameMath\";\r\n\r\n\r\n\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n\r\nexport enum TileMapDirection {\r\n    None = 0,\r\n    Right,\r\n    RightTop,\r\n    LeftTop,\r\n    Left,\r\n    LeftBottom,\r\n    RightBottom,\r\n}\r\n\r\n@ccclass\r\nexport default class TileMap extends EntityBase {\r\n\r\n    public static create(world: WorldBase): TileMap {\r\n        let node: cc.Node = null;\r\n        let res = AssetCache.getInstance().getAssetSync(AssetBundleID.GameScene, \"prefab/game_layer/TileMap\", cc.Prefab);\r\n        if (res) {\r\n            node = cc.instantiate(res as cc.Prefab);\r\n        }\r\n        if (node) {\r\n            node.setPosition(cc.v2(0, 0));\r\n            let component = node.getComponent(TileMap);\r\n            return component;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public init(world: WorldBase) {\r\n        if (this._stateMachine == null) {\r\n            super.initEntity(world);\r\n            this._stateMachine = TileMapStateMachine.create(this)\r\n            let width = 90;\r\n            let height = Math.round(width * Math.sin(GameMath.degreeToRadian(60)))// height = sin60度 * width\r\n            this.setCurrentState(TileMapStateCreate.create(cc.size(7, 7), cc.size(width, height)))\r\n        }\r\n    }\r\n\r\n    @property(cc.Node)\r\n    slotRoot: cc.Node = null\r\n    public getTileRoot(): cc.Node {\r\n        return this.slotRoot;\r\n    }\r\n\r\n    private _gameLayer: GameLayer = null;\r\n    public getGameLayer(): GameLayer {\r\n        return this._gameLayer;\r\n    }\r\n\r\n    public setGameLayer(gameLayer: GameLayer): void {\r\n        this._gameLayer = gameLayer;\r\n    }\r\n\r\n    private _tileSize: cc.Size = cc.size(90, 78);// height = sin60度 * width\r\n    public getTileSize(): cc.Size {\r\n        return this._tileSize\r\n    }\r\n    public setTileSize(size: cc.Size): void {\r\n        this._tileSize = size;\r\n    }\r\n    private _mapSize: cc.Size = cc.size(7, 7)\r\n    public getMapSize(): cc.Size {\r\n        return this._mapSize\r\n    }\r\n    public setMapSize(size: cc.Size): void {\r\n        this._mapSize = size;\r\n    }\r\n\r\n    private _origin: cc.Vec2 = cc.v2(0, 0);\r\n    public getOrigin(): cc.Vec2 {\r\n        return this._origin;\r\n    }\r\n    public setOrigin(origin: cc.Vec2): void {\r\n        this._origin = origin;\r\n    }\r\n\r\n    private _evenRowDirectionToOffsetDict = {};\r\n    public getEvenRowDirectionToOffsetDict(): Object {\r\n        return this._evenRowDirectionToOffsetDict;\r\n    }\r\n    public setEvenRowDirectionToOffsetDict(dict: Object): void {\r\n        this._evenRowDirectionToOffsetDict = dict;\r\n    }\r\n    private _oddRowDirectionToOffsetDict = {};\r\n    public getOddRowDirectionToOffsetDict(): Object {\r\n        return this._oddRowDirectionToOffsetDict;\r\n    }\r\n    public setOddRowDirectionToOffsetDict(dict: Object): void {\r\n        this._oddRowDirectionToOffsetDict = dict;\r\n    }\r\n\r\n    private _stateMachine: TileMapStateMachine = null\r\n    public getCurrentState(): TileMapStateBase {\r\n        return this._stateMachine.getCurrentState() as TileMapStateBase;\r\n    }\r\n    public setCurrentState(state: TileMapStateBase) {\r\n        this._stateMachine.setCurrentState(state);\r\n    }\r\n\r\n    private isSameWithCenter(row: number): boolean {\r\n        let isSameWithCenter = Math.floor(this._mapSize.height * 0.5) % 2 == row % 2\r\n        return isSameWithCenter;\r\n    }\r\n\r\n    public getPixelPosWithLogicalPos(pos: cc.Vec2): cc.Vec2 {\r\n        let isSameWithCenter = this.isSameWithCenter(pos.y);\r\n        let leftStart = this._tileSize.width * 0.5;\r\n        if (isSameWithCenter) {\r\n            leftStart = 0;\r\n        }\r\n\r\n        let x = leftStart + pos.x * this._tileSize.width;\r\n        let y = pos.y * this._tileSize.height;\r\n        return cc.v2(x, y).add(this._origin);\r\n    }\r\n\r\n    public getLogicalPosWithPixelPos(pos: cc.Vec2): cc.Vec2 {\r\n        let origin = this._origin.sub(cc.v2(this._tileSize.width * 0.5, this._tileSize.height * 0.5));\r\n        let offset = pos.sub(origin);\r\n        let row = Math.floor(offset.y / this._tileSize.height)\r\n\r\n        let isSameWithCenter = this.isSameWithCenter(row);\r\n        let leftStart = this._tileSize.width * 0.5;\r\n        if (isSameWithCenter) {\r\n            leftStart = 0;\r\n        }\r\n        let column = Math.floor((offset.x - leftStart) / this._tileSize.width)\r\n        return cc.v2(column, row);\r\n    }\r\n\r\n    public getOffsetWithPositionAndDirection(pos: cc.Vec2, direction: TileMapDirection): cc.Vec2 {\r\n        let isSameWithCenter = this.isSameWithCenter(pos.y);\r\n        if (isSameWithCenter) {\r\n            return this._oddRowDirectionToOffsetDict[direction];\r\n        } else {\r\n            return this._evenRowDirectionToOffsetDict[direction];\r\n        }\r\n    }\r\n\r\n    public getAllNeighbourPositions(pos: cc.Vec2): cc.Vec2[] {\r\n        let result: cc.Vec2[] = [];\r\n        let directions: TileMapDirection[] = [\r\n            TileMapDirection.Right,\r\n            TileMapDirection.RightTop,\r\n            TileMapDirection.LeftTop,\r\n            TileMapDirection.Left,\r\n            TileMapDirection.LeftBottom,\r\n            TileMapDirection.RightBottom,\r\n        ];\r\n\r\n        for (let index = 0; index < directions.length; index++) {\r\n            let direction = directions[index];\r\n            let offset = this.getOffsetWithPositionAndDirection(pos, direction);\r\n            let neighbourPos = pos.add(offset);\r\n            result.push(neighbourPos);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public getKeyWithLogicalPos(pos: cc.Vec2): string {\r\n        return pos.toString();\r\n    }\r\n\r\n    private _tileSlots: { [key: string]: TileSlot } = {};\r\n    public addSlotWithLogicalPos(slot: TileSlot, pos: cc.Vec2): void {\r\n        this.removeSlotWithLogicalPos(pos);\r\n        slot.setLogicalPostion(pos);\r\n        slot.node.setPosition(this.getPixelPosWithLogicalPos(pos));\r\n        this.slotRoot.addChild(slot.node, 0);\r\n        let key = this.getKeyWithLogicalPos(pos);\r\n        this._tileSlots[key] = slot;\r\n\r\n    }\r\n\r\n    public removeSlotWithLogicalPos(pos: cc.Vec2): TileSlot {\r\n        let key = this.getKeyWithLogicalPos(pos);\r\n        let slot: TileSlot = this._tileSlots[key];\r\n        if (slot) {\r\n            slot.node.removeFromParent(false);\r\n        }\r\n        delete this._tileSlots[key];\r\n        return slot;\r\n    }\r\n\r\n    public getSlotWithLogicalPos(pos: cc.Vec2): TileSlot {\r\n        let key = this.getKeyWithLogicalPos(pos)\r\n        return this._tileSlots[key];\r\n    }\r\n\r\n    public getAllSlots(): { [key: string]: TileSlot } {\r\n        return this._tileSlots;\r\n    }\r\n\r\n    public getAllValidPositions(): cc.Vec2[] {\r\n        let result: cc.Vec2[] = [];\r\n        for (const key in this._tileSlots) {\r\n            const slot = this._tileSlots[key];\r\n            let logicalPos = slot.getLogicalPosition();\r\n            result.push(logicalPos);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private _tiles: { [key: string]: Tile } = {};\r\n    public addTileWithLogicalPos(tile: Tile, pos: cc.Vec2): void {\r\n        let slot = this.getSlotWithLogicalPos(pos)\r\n        if (slot) {\r\n            this.removeTileWithLogicalPos(pos);\r\n            tile.setLogicalPostion(pos);\r\n            tile.node.setPosition(this.getPixelPosWithLogicalPos(pos));\r\n            this.slotRoot.addChild(tile.node, 1);\r\n            let key = this.getKeyWithLogicalPos(pos);\r\n            this._tiles[key] = tile;\r\n        }\r\n    }\r\n\r\n    public removeTileWithLogicalPos(pos: cc.Vec2): Tile {\r\n        let key = this.getKeyWithLogicalPos(pos);\r\n        let tile: Tile = this._tiles[key];\r\n        if (tile) {\r\n            tile.node.removeFromParent(false);\r\n        }\r\n        delete this._tiles[key];\r\n        return tile;\r\n    }\r\n\r\n    public getTileWithLogicalPos(pos: cc.Vec2): Tile {\r\n        let key = this.getKeyWithLogicalPos(pos)\r\n        return this._tiles[key];\r\n    }\r\n\r\n\r\n    public isTileSlotEmptyAtLogicalPos(pos: cc.Vec2): boolean {\r\n        let slot = this.getSlotWithLogicalPos(pos);\r\n        if (slot) {\r\n            let tile = this.getTileWithLogicalPos(pos);\r\n            if (!tile) {\r\n                return true\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public insertTilePiece(tilePiece: TilePiece): cc.Vec2[] {\r\n        let state = this.getCurrentState()\r\n        if (state.getType() == TileMapStateType.Inlay) {\r\n            let idleState = state as TileMapStateInlay\r\n            return idleState.inlayTilePiece(this, tilePiece);\r\n        }\r\n        return []\r\n    }\r\n\r\n\r\n    public haveEnoughSlotForTilePiece(tilePiece: TilePiece): boolean {\r\n        let state = this.getCurrentState()\r\n        if (state.getType() == TileMapStateType.Inlay) {\r\n            let inlayState = state as TileMapStateInlay\r\n            return inlayState.haveEnoughSlotForTilePiece(this, tilePiece);\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n    public addAnimationTileWithLogicalPos(tile: Tile, pos: cc.Vec2): void {\r\n        tile.node.setPosition(this.getPixelPosWithLogicalPos(pos));\r\n        this.slotRoot.addChild(tile.node, 2);\r\n    }\r\n\r\n    public removeAnimationTile(tile: Tile) {\r\n        tile.recycle()\r\n    }\r\n\r\n}\r\n","import { AssetBundleID } from \"../../../../../scripts/Defines/Defines\";\r\nimport EntityBase from \"../../../../../scripts/Frameworks/EWS/Entity/EntityBase\";\r\nimport EntityNodePool from \"../../../../../scripts/Frameworks/EWS/Entity/EntityNodePool\";\r\nimport WorldBase from \"../../../../../scripts/Frameworks/EWS/World/WorldBase\";\r\nimport GameMath from \"../../../../../scripts/Frameworks/Utils/GameMath\";\r\nimport Tile from \"../Tile/Tile\";\r\n\r\nconst { ccclass, property } = cc._decorator;\r\nexport class TilePieceInfo {\r\n    public levels: number[] = [];\r\n    public angleIndex: number = 0;\r\n\r\n    constructor(levels: number[], angleIndex: number) {\r\n        this.levels = levels;\r\n        this.angleIndex = angleIndex;\r\n    }\r\n}\r\n\r\n@ccclass\r\nexport default class TilePiece extends EntityBase {\r\n\r\n    public static create(world: WorldBase, info: TilePieceInfo): TilePiece {\r\n        let entity = EntityNodePool.getInstance().getEntityNode(AssetBundleID.GameScene,\r\n            \"prefab/game_layer/TilePiece\", \"TilePiece\");\r\n        if (entity) {\r\n            let tile: TilePiece = entity as TilePiece;\r\n            tile.init(world, info);\r\n            return tile;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @property(Tile)\r\n    tile1: Tile = null;\r\n\r\n    @property(Tile)\r\n    tile2: Tile = null;\r\n\r\n    private _radius: number = 45;\r\n    private _levels: number[] = [];\r\n    public getLevels(): number[] {\r\n        return this._levels;\r\n    }\r\n    private setLevels(levels: number[]) {\r\n        if (levels.length == 1) {\r\n            this._levels = levels;\r\n            this.tile2.node.active = false;\r\n            this.tile1.node.active = true;\r\n        } else if (levels.length == 2) {\r\n            this._levels = levels;\r\n            this.tile1.node.active = true;\r\n            this.tile1.setLevel(levels[0]);\r\n            this.tile2.node.active = true;\r\n            this.tile2.setLevel(levels[1]);\r\n        } else {\r\n            this._levels = [];\r\n            this.tile1.node.active = false;\r\n            this.tile2.node.active = false;\r\n            console.error(\"Tile Piece should have 1 or 2 tiles\")\r\n        }\r\n    }\r\n\r\n    private _angleIndex: number = 0;\r\n    public getAngleIndex(): number {\r\n        return this._angleIndex;\r\n    }\r\n    private setAngleIndex(index: number, animated: boolean = false) {\r\n        if (this._levels.length == 1) {\r\n            this._angleIndex = 0;\r\n            this.tile1.setPosition(cc.v2(0, 0))\r\n            this.tile2.setPosition(cc.v2(0, 0))\r\n        } else {\r\n            this._angleIndex = index % 6;\r\n            let radins = GameMath.degreeToRadian(this._angleIndex * -60 + 180)\r\n            let pos1 = cc.v2(Math.cos(radins) * this._radius, Math.sin(radins) * this._radius)\r\n            let pos2 = pos1.mul(-1);\r\n\r\n            this.tile1.node.stopActionByTag(1001);\r\n            this.tile2.node.stopActionByTag(1001);\r\n\r\n            if (animated) {\r\n                let move1 = cc.moveTo(0.2, pos1).easing(cc.easeOut(2));\r\n                move1.setTag(1001)\r\n                this.tile1.node.runAction(move1)\r\n\r\n                let move2 = cc.moveTo(0.2, pos2).easing(cc.easeOut(2));\r\n                move2.setTag(1001)\r\n                this.tile2.node.runAction(move2)\r\n            } else {\r\n                this.tile1.setPosition(pos1);\r\n                this.tile2.setPosition(pos2);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public init(world: WorldBase, info: TilePieceInfo) {\r\n        this.initEntity(world);\r\n        this.setTilePieceInfo(info);\r\n    }\r\n\r\n    public getTilePieceInfo(): TilePieceInfo {\r\n        let levels = this._levels.slice(0);\r\n        let angleIndex = this._angleIndex;\r\n        let result = new TilePieceInfo(levels, angleIndex);\r\n        return result;\r\n    }\r\n    public setTilePieceInfo(info: TilePieceInfo) {\r\n        this.setLevels(info.levels);\r\n        this.setAngleIndex(info.angleIndex);\r\n    }\r\n\r\n    public rotate(): void {\r\n        this.setAngleIndex(this.getAngleIndex() + 1, true)\r\n    }\r\n\r\n    public getTiles(): Tile[] {\r\n        let result: Tile[] = [];\r\n        if (this._levels.length == 1) {\r\n            result.push(this.tile1);\r\n        } else if (this._levels.length == 2) {\r\n            result.push(this.tile1);\r\n            result.push(this.tile2);\r\n        } else {\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","import { AssetBundleID } from \"../../../../../scripts/Defines/Defines\";\r\nimport EntityNodePool from \"../../../../../scripts/Frameworks/EWS/Entity/EntityNodePool\";\r\nimport WorldBase from \"../../../../../scripts/Frameworks/EWS/World/WorldBase\";\r\nimport TileBase, { TileType } from \"./TileBase\";\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n@ccclass\r\nexport default class TileSlot extends TileBase {\r\n\r\n    public static create(world: WorldBase): TileSlot {\r\n        let entity = EntityNodePool.getInstance().getEntityNode(AssetBundleID.GameScene,\r\n            \"prefab/game_layer/TileSlot\", \"TileSlot\");\r\n        if (entity) {\r\n            let tileSlot: TileSlot = entity as TileSlot;\r\n            tileSlot.init(world);\r\n            return tileSlot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected init(world: WorldBase) {\r\n        this.initWithType(world, TileType.Slot)\r\n    }\r\n}\r\n","import { AssetBundleID } from \"../../../../../scripts/Defines/Defines\";\r\nimport AssetCache from \"../../../../../scripts/Frameworks/AssetCache/AssetCache\";\r\nimport EntityNodePool from \"../../../../../scripts/Frameworks/EWS/Entity/EntityNodePool\";\r\nimport WorldBase from \"../../../../../scripts/Frameworks/EWS/World/WorldBase\";\r\nimport TileBase, { TileType } from \"./TileBase\";\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n@ccclass\r\nexport default class Tile extends TileBase {\r\n\r\n    public static create(world: WorldBase, level: number): Tile {\r\n        let entity = EntityNodePool.getInstance().getEntityNode(AssetBundleID.GameScene, \"prefab/game_layer/Tile\", \"Tile\");\r\n        if (entity) {\r\n            let tile: Tile = entity as Tile;\r\n            tile.initWithLevel(world, level);\r\n            return tile;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @property(cc.Label)\r\n    label: cc.Label = null;\r\n\r\n    @property(cc.Sprite)\r\n    tile: cc.Sprite = null;\r\n\r\n    // LIFE-CYCLE CALLBACKS:\r\n\r\n    // onLoad () {}\r\n\r\n    start() {\r\n\r\n    }\r\n\r\n    // update (dt) {}\r\n\r\n    private static MaxLevel = 7;\r\n    private static MinLevel = 1;\r\n    private _level: number = Tile.MinLevel;\r\n    public getLevel(): number {\r\n        return this._level;\r\n    }\r\n\r\n    public setLevel(level: number): void {\r\n        this._level = Math.max(Tile.MinLevel, Math.min(level, Tile.MaxLevel));\r\n        this.label.string = this._level.toString();\r\n\r\n        let frameName = \"texture/game_layer/kuaizi_\" + this._level;\r\n        let spriteFrame = AssetCache.getInstance().getAssetSync(AssetBundleID.GameScene, frameName, cc.SpriteFrame);\r\n        if (spriteFrame) {\r\n            this.tile.spriteFrame = spriteFrame as cc.SpriteFrame\r\n        }\r\n    }\r\n\r\n    protected initWithLevel(world: WorldBase, level: number) {\r\n        this.initWithType(world, TileType.Tile);\r\n        this.setLevel(level);\r\n    }\r\n\r\n    public onRecycle() {\r\n        super.onRecycle();\r\n        this.node.rotation = 0;\r\n        this.node.scale = 1;\r\n        this.node.anchorX = 0.5;\r\n        this.node.anchorY = 0.5;\r\n        this.node.opacity = 255;\r\n        this.node.color = cc.color(255, 255, 255, 255);\r\n    }\r\n}\r\n"],"file":"index.js"}