{"version":3,"sources":["assets/bundles/chat_scene/script/ChatScene.ts","assets/bundles/chat_scene/script/Logic/Base/LogicBase.ts","assets/bundles/chat_scene/script/LogicCenter/LogicCenter.ts","assets/bundles/chat_scene/script/LogicCenter/Logic/Chat/LogicChat.ts","assets/bundles/chat_scene/script/LogicCenter/Logic/LogicFactory.ts","assets/bundles/chat_scene/script/SocketCenter/SocketCenter.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Battle/SocketDispatcherBattle.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Chat/SocketDispatcherChat.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Common/SocketDispatcherCommon.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/SocketDsipatcherFactory.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Battle/SocketHeartBeatBattle.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Chat/SocketHeartBeatChat.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Common/SocketHeartBeatCommon.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Battle/SocketMessagePhraserBattle.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Chat/SocketMessagePhraserChat.ts","assets/bundles/chat_scene/script/SocketCenter/Dispatchers/Common/SocketMessagePhraserCommon.ts","assets/bundles/chat_scene/script/SocketCenter/Proto/proto.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGM;AAGN;AAAuC;AAAvC;;AAkFA;AA/EW;AACH;AACJ;AACO;AACH;AACJ;AACO;AAEP;AACO;AAEP;AACO;AAEP;AACO;AAEP;AACO;AAEP;AACO;AAEP;AACO;AAEP;AAEU;AACN;AACJ;AAEU;AACN;AACJ;AAEU;AACN;AACJ;AAEU;AACN;AACA;AACA;AACJ;AAEQ;AACJ;AACJ;AAEQ;AACJ;AACA;AACI;AACH;AACD;AACJ;AAEQ;AAAuB;AAC3B;AACA;AACI;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AAEQ;AACJ;AACA;AACI;AACH;AACD;AACJ;AAjFiB;AADpB;AACoB;AAkFrB;AAlFA;AAAqB;;;;;;;;;;;ACZrB;AAAA;AACI;AACA;AACJ;AAEA;AAAA;AACY;AAQZ;AAPc;AACN;AACJ;AAKJ;AAAA;;;;;;;;;;;ACdA;AAEA;AAAA;AASY;AAYZ;AAnBkB;AACV;AACI;AACH;AACD;AACJ;AAGO;AACH;AACA;AACI;AACA;AACI;AACH;AACJ;AACD;AACJ;AAlBe;AAoBnB;AArBA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;ACJrB;AACA;AACA;AACA;AACA;AAKA;AAAA;AACI;AACA;AACJ;AAEA;AAAuC;AAAvC;AAAA;AAQY;;AAsEZ;AA5EkB;AACV;AACA;AACA;AACJ;AAGU;AACN;AACA;AACA;AACI;AACA;AACA;AACA;AACA;AACH;AACL;AAEQ;AACJ;AACJ;AAEQ;AACJ;AACA;AACA;AACA;AACA;AACI;AACH;AACL;AAEQ;AACJ;AACJ;AAEQ;AACJ;AACJ;AAEQ;AACJ;AACA;AACA;AACI;AACA;AACH;AAAM;AACH;AACH;AACL;AAEQ;AACJ;AACA;AACA;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACI;AACH;AACD;AACA;AACJ;AAEO;AACH;AACA;AACA;AACJ;AACJ;AAAA;;;;;;;;;;;AC3FA;AACA;AAGA;AAAA;AAUA;AATkB;AACV;AACI;AACI;AACJ;AACI;AACP;AACD;AACJ;AACJ;AAAA;;;;;;;;;;;ACZA;AAEA;AAAA;AASY;AAYZ;AAnBkB;AACV;AACI;AACH;AACD;AACJ;AAGO;AACH;AACA;AACI;AACA;AACI;AACH;AACJ;AACD;AACJ;AAlBe;AAoBnB;AArBA;AAAqB;;;;;;;;;;;;;;;;;;;;;;;ACJrB;AAIA;AACA;AACA;AACA;AAGA;AAAoD;AAApD;;AAkBA;AAhBkB;AACV;AACA;AAIA;AACJ;AAEU;AAIN;AACJ;AAEJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AAIA;AACA;AACA;AACA;AAEA;AAAkD;AAAlD;;AAkBA;AAhBkB;AACV;AACA;AAIA;AACJ;AAEU;AAIN;AACJ;AAEJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC1BA;AAIA;AAEA;AAAoD;AAApD;;AAsCA;AApCc;AAIN;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACI;AACH;AACD;AACA;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACI;AACH;AACD;AACJ;AACJ;AAAA;;;;;;;;;;;AC5CA;AACA;AACA;AAGA;AAAA;AAaA;AAZkB;AACV;AACI;AACI;AACJ;AACI;AAEJ;AACI;AACP;AACD;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AAEA;AAAmD;AAAnD;;AAWA;AATkB;AACV;AACA;AACA;AACJ;AAEU;AACN;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AAEA;AAAiD;AAAjD;;AAWA;AATkB;AACV;AACA;AACA;AACJ;AAEU;AACN;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AAEA;AAAmD;AAAnD;;AAmBA;AAhBc;AACN;AACJ;AAEO;AACH;AACA;AACA;AACA;AACJ;AAEO;AACH;AACI;AACH;AACL;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AAEA;AAAwD;AAAxD;;AAWA;AATkB;AACV;AACA;AACA;AACJ;AAEU;AACN;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AAEA;AAAsD;AAAtD;;AAWA;AATkB;AACV;AACA;AACA;AACJ;AAEU;AACN;AACJ;AACJ;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAEA;AAEA;AAAwD;AAAxD;;AAuCA;AArCc;AACN;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AAEO;AACH;AACA;AACA;AACA;AACA;AACA;AACJ;AAEO;AACH;AACA;AACJ;AAEO;AACH;AACA;AACJ;AACJ;AAAA;;;;;;;;;AC9CA;AACA;;AAEA;;;AAGA;AAAA;AAAA;;AAGA;;AAEA;AAEI;;;;;AAKA;AAEA;;;;;;;AAMA;AACI;AAAA;AACA;AACA;AACH;AAED;;;;;;;;AAMA;AACI;AAAA;AACA;AACA;AACH;;AAED;AAEI;;;;;;;;;AASA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;AAZJ;AAcH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;AAGA;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;AAEA;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;;AACA;AACI;AACA;AACA;AACH;;AACD;AAEA;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;;AAED;AACH;;AAED;AAEI;;;;;AAKA;AAEA;;;;;;;AAMA;AACI;AAAA;AACA;AACA;AACH;AAED;;;;;;;;AAMA;AACI;AAAA;AACA;AACA;AACH;;AAED;AAEI;;;;;;;;AAQA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;AATJ;AAWH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;;AACA;AACI;AACA;AACH;;AACD;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;;AAED;AAEI;;;;;;;;;AASA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AAC6D;AAAuB;AACpF;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;AAZJ;AAcH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;;AAGA;AACI;AACA;AAEH;;AACD;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;;AAEA;AACI;AAEA;AACH;;AACD;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;;AACA;AACI;AACA;AACA;AACH;;AACD;AAEA;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;AAED;;;;;;;;;AAOA;AACI;AAAA;AACA;AACA;AACA;AACH;;AAED;AAEI;;;;;;;;;;AAUA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AAC6D;AAAuB;AACpF;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;AAfJ;AAiBH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;;AAGA;AACI;AACA;AAEH;;AACD;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;;AAEA;AACI;AAEA;AACH;;AACD;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;;AACA;AACI;AACA;AACA;AACA;AACH;;AACD;AAEA;AAEA;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;;AAED;AACH;;AAED;AAEI;;;;;AAKA;AAEA;;;;;;;;;;;AAUA;AACI;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACH;;AAED;AAEI;;;;;;;AAOA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;AANJ;AAQH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACA;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;AAED;;;;;;;;;AAOA;AACI;AAAA;AACA;AACA;AACA;AACH;;AAED;AAEI;;;;;;;;AAQA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;AATJ;AAWH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;;AACA;AACI;AACA;AACH;;AACD;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;;AAED;AAEI;;;;;;;AAOA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;AANJ;AAQH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACA;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;AAED;;;;;;;;;AAOA;AACI;AAAA;AACA;AACA;AACA;AACH;;AAED;AAEI;;;;;;;;AAQA;;;;;;;;AAQA;AACI;AAEQ;AADJ;AAGP;AAED;;;;;;;;AAMA;AAEA;;;;;;;AAMA;AAEA;;;;;;;;;AAQA;AACI;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;AACkB;AAAuB;AACzC;AACkB;AAAuB;AACzC;AACH;AAED;;;;;;;;;;;AASA;AACI;AACH;AAED;;;;;;;;;;;;;AAWA;AACI;AAEA;AAAA;;AACA;AACI;;AACA;AACA;AACI;AACA;;AACJ;AACI;AACA;;AACJ;AACI;AACA;AATJ;AAWH;;AACD;AACH;AAED;;;;;;;;;;;;AAUA;AACI;AAEA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AAGA;AAGA;AACH;AAED;;;;;;;;;;AAQA;AACI;AAEA;AACA;AAEA;AAEA;AACH;AAED;;;;;;;;;;;AASA;AACI;AAEA;;AACA;AACI;AACA;AACH;;AACD;AAEA;AAEA;AACH;AAED;;;;;;;;;AAOA;AACI;AACH;;AAED;AACH;;AAED;AACH;;AAED","sourcesContent":["\r\nimport { SceneName } from \"../../../scripts/Defines/Defines\";\r\nimport HttpWrapperWeb from \"../../../scripts/Frameworks/Network/Http/HttpWrapper/Web/HttpWrapperWeb\";\r\nimport PlayerInfo from \"../../../scripts/Frameworks/PlayerInfo/PlayerInfo\";\r\nimport SceneBase from \"../../../scripts/Frameworks/SceneDirector/SceneBase\";\r\nimport SceneEnterParamBase from \"../../../scripts/Frameworks/SceneDirector/SceneEnterParamBase\";\r\nimport LogicBase, { LogicName } from \"./Logic/Base/LogicBase\";\r\nimport LogicCenter from \"./LogicCenter/LogicCenter\";\r\nimport { Chat } from \"./SocketCenter/Proto/proto\";\r\n\r\n\r\nconst { ccclass, property } = cc._decorator;\r\n\r\n@ccclass\r\nexport default class ChatScene extends SceneBase {\r\n\r\n\r\n    public getSceneName(): string {\r\n        return SceneName.ChatScene;\r\n    }\r\n    public onSceneLoad(): void {\r\n        PlayerInfo.getInstance().setUserID(\"player_10001\")\r\n    }\r\n    public onSceneEnable(): void {\r\n\r\n    }\r\n    public onSceneEnter(param: SceneEnterParamBase): void {\r\n\r\n    }\r\n    public onSceneStart(): void {\r\n\r\n    }\r\n    public onSceneUpdate(dt: number): void {\r\n\r\n    }\r\n    public onSceneExit(): void {\r\n\r\n    }\r\n    public onSceneDisable(): void {\r\n\r\n    }\r\n    public onSceneDestroy(): void {\r\n\r\n    }\r\n\r\n    protected onSocketConnectBtn(event: cc.Event.EventTouch) {\r\n        this.login();\r\n    }\r\n\r\n    protected onSocketSendBtn(event: cc.Event.EventTouch) {\r\n        this.sendWord(\"Hello Everyone\");\r\n    }\r\n\r\n    protected onSocketCloseBtn(event: cc.Event.EventTouch) {\r\n        this.logout();\r\n    }\r\n\r\n    protected onHttpSendBtn(event: cc.Event.EventTouch) {\r\n        let http = HttpWrapperWeb.create(\"http://10.12.131.39:3000\")\r\n        http.connect();\r\n        http.send(\"test\");\r\n    }\r\n\r\n    private getChatLogic(): LogicBase {\r\n        return LogicCenter.getInstance().getLogic(LogicName.Chat);\r\n    }\r\n\r\n    private login() {\r\n        let logic = this.getChatLogic();\r\n        if (logic == null) {\r\n            return\r\n        }\r\n        logic.run();\r\n    }\r\n\r\n    private sendWord(word: string, receuverID: string = \"\") {\r\n        let logic = this.getChatLogic();\r\n        if (logic == null) {\r\n            return\r\n        }\r\n        let msg = Chat.MessageRequest.create();\r\n        msg.senderId = PlayerInfo.getInstance().getUserID();\r\n        msg.receiverId = receuverID;\r\n        msg.message = Chat.Message.create();\r\n        msg.message.word = word;\r\n        let buffer = Chat.MessageRequest.encode(msg).finish();\r\n        logic.sendMessage({ cmd: Chat.C2S_CMD.Message, data: buffer });\r\n    }\r\n\r\n    private logout() {\r\n        let logic = this.getChatLogic();\r\n        if (logic == null) {\r\n            return\r\n        }\r\n        logic.stop();\r\n    }\r\n}\r\n","\r\n\r\nexport enum LogicName {\r\n    None = \"None\",\r\n    Chat = \"Chat\",\r\n}\r\n\r\nexport default abstract class LogicBase {\r\n    private _name: LogicName = LogicName.None;\r\n    protected initBase(name: LogicName) {\r\n        this._name = name;\r\n    }\r\n\r\n    public abstract run();\r\n    public abstract sendMessage(msg: any);\r\n    public abstract stop();\r\n}","\r\nimport LogicBase, { LogicName } from \"../Logic/Base/LogicBase\";\r\nimport LogicFactory from \"./Logic/LogicFactory\";\r\n\r\nexport default class LogicCenter {\r\n    private static _instance: LogicCenter = null;\r\n    public static getInstance(): LogicCenter {\r\n        if (this._instance == null) {\r\n            this._instance = new LogicCenter();\r\n        }\r\n        return this._instance;\r\n    }\r\n\r\n    private _logicDict: { [key: string]: LogicBase } = {};\r\n    public getLogic(name: LogicName): LogicBase {\r\n        let logic = this._logicDict[name];\r\n        if (logic == null) {\r\n            logic = LogicFactory.createLogic(name);\r\n            if (logic) {\r\n                this._logicDict[name] = logic;\r\n            }\r\n        }\r\n        return logic;\r\n    }\r\n\r\n}\r\n","import SocketDispatcherBase, { SocketName } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketDispatcher/Base/SocketDispatcherBase\";\r\nimport PlayerInfo from \"../../../../../../scripts/Frameworks/PlayerInfo/PlayerInfo\";\r\nimport LogicBase, { LogicName } from \"../../../Logic/Base/LogicBase\";\r\nimport { Login, Chat } from \"../../../SocketCenter/Proto/proto\";\r\nimport SocketCenter from \"../../../SocketCenter/SocketCenter\";\r\n\r\n\r\n\r\n\r\nenum LogicChatState {\r\n    Stopped = 0,\r\n    Running\r\n}\r\n\r\nexport default class LogicChat extends LogicBase {\r\n\r\n    public static create(): LogicChat {\r\n        let instance = new LogicChat();\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    private _state: LogicChatState = LogicChatState.Stopped;\r\n    protected init() {\r\n        super.initBase(LogicName.Chat);\r\n        let dispatcher = SocketCenter.getInstance().getDispatcher(SocketName.Chat);\r\n        if (dispatcher) {\r\n            dispatcher.registListener(Login.S2C_CMD.Open, this.onOpen, this);\r\n            dispatcher.registListener(Login.S2C_CMD.Login, this.onLogin, this);\r\n            dispatcher.registListener(Chat.S2C_CMD.Message, this.onMessage, this);\r\n            dispatcher.registListener(Login.S2C_CMD.Error, this.onError, this);\r\n            dispatcher.registListener(Login.S2C_CMD.Closed, this.onClosed, this);\r\n        }\r\n    }\r\n\r\n    private getSocketDispatcher(): SocketDispatcherBase {\r\n        return SocketCenter.getInstance().getDispatcher(SocketName.Chat);\r\n    }\r\n\r\n    private onOpen(event: cc.Event.EventCustom) {\r\n        let req = Login.LoginRequest.create()\r\n        req.userId = PlayerInfo.getInstance().getUserID();\r\n        let reqBuf = Login.LoginRequest.encode(req).finish();\r\n        let dispatcher = SocketCenter.getInstance().getDispatcher(SocketName.Chat);\r\n        if (dispatcher) {\r\n            dispatcher.sendMessage({ cmd: Login.C2S_CMD.Login, data: reqBuf });\r\n        }\r\n    }\r\n\r\n    private onError(event: cc.Event.EventCustom) {\r\n        this._state = LogicChatState.Stopped;\r\n    }\r\n\r\n    private onClosed(event: cc.Event.EventCustom) {\r\n        this._state = LogicChatState.Stopped;\r\n    }\r\n\r\n    private onLogin(event: cc.Event.EventCustom) {\r\n        let buffer = event.getUserData();\r\n        let resp = Login.LoginRespone.decode(buffer);\r\n        if (resp.result == Login.LoginErrorCode.Succeed) {\r\n            this._state = LogicChatState.Running;\r\n            console.log(\"LogicChat.onLogin Succeed\")\r\n        } else {\r\n            console.error(\"LogicChat.onLogin Failed:\", resp.result);\r\n        }\r\n    }\r\n\r\n    private onMessage(event: cc.Event.EventCustom) {\r\n        let buffer = event.getUserData();\r\n        let message = Chat.MessageRespone.decode(buffer);\r\n        console.log(\"LogicChat.onMessage\", message);\r\n    }\r\n\r\n    public run() {\r\n        let dispatcher = this.getSocketDispatcher()\r\n        dispatcher.connect();\r\n    }\r\n\r\n    public sendMessage(msg: { cmd: number, data: any }) {\r\n        if (this._state != LogicChatState.Running) {\r\n            return;\r\n        }\r\n        let dispatcher = this.getSocketDispatcher();\r\n        dispatcher.sendMessage(msg);\r\n    }\r\n\r\n    public stop() {\r\n        this._state = LogicChatState.Stopped;\r\n        let dispatcher = this.getSocketDispatcher();\r\n        dispatcher.close();\r\n    }\r\n}","\r\nimport LogicBase, { LogicName } from \"../../Logic/Base/LogicBase\";\r\nimport LogicChat from \"./Chat/LogicChat\";\r\n\r\n\r\nexport default class LogicFactory {\r\n    public static createLogic(name: LogicName): LogicBase {\r\n        switch (name) {\r\n            case LogicName.Chat:\r\n                return LogicChat.create();\r\n            default:\r\n                break;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n","\r\n\r\nimport SocketDispatcherBase, { SocketName } from \"../../../../scripts/Frameworks/Network/Socket/SocketDispatcher/Base/SocketDispatcherBase\";\r\nimport SocketDispatcherFactory from \"./Dispatchers/SocketDsipatcherFactory\";\r\n\r\nexport default class SocketCenter {\r\n    private static _instance: SocketCenter = null;\r\n    public static getInstance(): SocketCenter {\r\n        if (this._instance == null) {\r\n            this._instance = new SocketCenter();\r\n        }\r\n        return this._instance;\r\n    }\r\n\r\n    private _dispatcherDict: { [key: string]: SocketDispatcherBase } = {};\r\n    public getDispatcher(name: SocketName): SocketDispatcherBase {\r\n        let dispatcher = this._dispatcherDict[name];\r\n        if (dispatcher == null) {\r\n            dispatcher = SocketDispatcherFactory.createSocketDispatcher(name);\r\n            if (dispatcher) {\r\n                this._dispatcherDict[name] = dispatcher;\r\n            }\r\n        }\r\n        return dispatcher;\r\n    }\r\n\r\n}\r\n","\r\nimport { SocketName } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketDispatcher/Base/SocketDispatcherBase\";\r\nimport SocketHeartBeatBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketHeartBeat/Base/SocketHeartBeatBase\";\r\nimport SocketMessagePhraserBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketMessagePhraser/Base/SocketMessagePhraserBase\";\r\nimport { SocketWrapperBase } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketWrapper/Base/SocketWrapperBase\";\r\nimport SocketFactory from \"../../../../../../scripts/Frameworks/Network/Socket/SocketWrapper/SocketFactory\";\r\nimport SocketDispatcherCommon from \"../Common/SocketDispatcherCommon\";\r\nimport SocketHeartBeatBattle from \"./SocketHeartBeatBattle\";\r\nimport SocketMessagePhraserBattle from \"./SocketMessagePhraserBattle\";\r\n\r\n\r\nexport default class SocketDispatcherBattle extends SocketDispatcherCommon {\r\n\r\n    public static create(): SocketDispatcherBattle {\r\n        let instance = new SocketDispatcherBattle();\r\n        instance.init(SocketName.Battle,\r\n            SocketFactory.createSocketWrapper(\"ws://10.12.131.39:8182\", instance),\r\n            SocketHeartBeatBattle.create(),\r\n            SocketMessagePhraserBattle.create());\r\n        return instance;\r\n    }\r\n\r\n    protected init(name: SocketName,\r\n        socket: SocketWrapperBase,\r\n        heartBeat: SocketHeartBeatBase,\r\n        messagePhraser: SocketMessagePhraserBase) {\r\n        super.initCommon(name, socket, heartBeat, messagePhraser);\r\n    }\r\n\r\n}\r\n","\r\n\r\nimport { SocketName } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketDispatcher/Base/SocketDispatcherBase\";\r\nimport SocketHeartBeatBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketHeartBeat/Base/SocketHeartBeatBase\";\r\nimport SocketMessagePhraserBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketMessagePhraser/Base/SocketMessagePhraserBase\";\r\nimport { SocketWrapperBase } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketWrapper/Base/SocketWrapperBase\";\r\nimport SocketFactory from \"../../../../../../scripts/Frameworks/Network/Socket/SocketWrapper/SocketFactory\";\r\nimport SocketDispatcherCommon from \"../Common/SocketDispatcherCommon\";\r\nimport SocketHeartBeatChat from \"./SocketHeartBeatChat\";\r\nimport SocketMessagePhraserChat from \"./SocketMessagePhraserChat\";\r\n\r\nexport default class SocketDispatcherChat extends SocketDispatcherCommon {\r\n\r\n    public static create(): SocketDispatcherChat {\r\n        let instance = new SocketDispatcherChat();\r\n        instance.init(SocketName.Chat,\r\n            SocketFactory.createSocketWrapper(\"ws://10.12.131.39:8181\", instance),\r\n            SocketHeartBeatChat.create(),\r\n            SocketMessagePhraserChat.create());\r\n        return instance;\r\n    }\r\n\r\n    protected init(name: SocketName,\r\n        socket: SocketWrapperBase,\r\n        heartBeat: SocketHeartBeatBase,\r\n        messagePhraser: SocketMessagePhraserBase) {\r\n        super.initCommon(name, socket, heartBeat, messagePhraser);\r\n    }\r\n\r\n}\r\n","\r\n\r\n\r\nimport SocketDispatcherBase, { SocketName } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketDispatcher/Base/SocketDispatcherBase\";\r\nimport SocketHeartBeatBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketHeartBeat/Base/SocketHeartBeatBase\";\r\nimport SocketMessagePhraserBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketMessagePhraser/Base/SocketMessagePhraserBase\";\r\nimport { SocketWrapperBase } from \"../../../../../../scripts/Frameworks/Network/Socket/SocketWrapper/Base/SocketWrapperBase\";\r\nimport { Login } from \"../../Proto/proto\";\r\n\r\nexport default class SocketDispatcherCommon extends SocketDispatcherBase {\r\n\r\n    protected initCommon(name: SocketName,\r\n        socket: SocketWrapperBase,\r\n        heartBeat: SocketHeartBeatBase,\r\n        messagePhraser: SocketMessagePhraserBase) {\r\n        super.initBase(name, socket, heartBeat, messagePhraser);\r\n    }\r\n\r\n    public onOpen(msg: { cmd: number, data: any }) {\r\n        console.log(\"SocketDispatcherChat.onOpen\")\r\n        this.dispatchEvent(msg.cmd, msg.data);\r\n    }\r\n\r\n    public onMessage(msg: { cmd: number, data: Uint8Array }) {\r\n        if (msg.cmd == Login.S2C_CMD.HeartBeat) {\r\n            return;\r\n        }\r\n        console.log(\"SocketDispatcherChat.onMessage\", msg.cmd);\r\n        this.dispatchEvent(msg.cmd, msg.data);\r\n    }\r\n\r\n    public onError(msg: { cmd: number, data: any }) {\r\n        console.log(\"SocketDispatcherChat.onError\")\r\n        this.dispatchEvent(msg.cmd, msg.data);\r\n    }\r\n\r\n    public onClosed(msg: { cmd: number, data: any }) {\r\n        console.log(\"SocketDispatcherChat.onClosed\")\r\n        this.dispatchEvent(msg.cmd, msg.data);\r\n    }\r\n\r\n    public sendMessage(msg: { cmd: number, data: any }) {\r\n        if (msg.cmd != Login.C2S_CMD.HeartBeat) {\r\n            console.log(\"SocketDispatcherChat.sendMessage\", msg.cmd);\r\n        }\r\n        super.sendMessage(msg);\r\n    }\r\n}\r\n","\r\n\r\n\r\nimport SocketDispatcherBase, { SocketName } from \"../../../../../scripts/Frameworks/Network/Socket/SocketDispatcher/Base/SocketDispatcherBase\";\r\nimport SocketDispatcherBattle from \"./Battle/SocketDispatcherBattle\";\r\nimport SocketDispatcherChat from \"./Chat/SocketDispatcherChat\";\r\n\r\n\r\nexport default class SocketDispatcherFactory {\r\n    public static createSocketDispatcher(name: SocketName): SocketDispatcherBase {\r\n        switch (name) {\r\n            case SocketName.Battle:\r\n                return SocketDispatcherBattle.create();\r\n            case SocketName.Chat:\r\n                return SocketDispatcherChat.create();\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n","\r\nimport SocketHeartBeatCommon from \"../Common/SocketHeartBeatCommon\";\r\n\r\nexport default class SocketHeartBeatBattle extends SocketHeartBeatCommon {\r\n\r\n    public static create(): SocketHeartBeatBattle {\r\n        let instance = new SocketHeartBeatBattle;\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    protected init() {\r\n        super.initCommon();\r\n    }\r\n}","\r\nimport SocketHeartBeatCommon from \"../Common/SocketHeartBeatCommon\";\r\n\r\nexport default class SocketHeartBeatChat extends SocketHeartBeatCommon {\r\n\r\n    public static create(): SocketHeartBeatChat {\r\n        let instance = new SocketHeartBeatChat;\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    protected init() {\r\n        super.initCommon();\r\n    }\r\n}","\r\n\r\nimport SocketHeartBeatBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketHeartBeat/Base/SocketHeartBeatBase\";\r\nimport PlayerInfo from \"../../../../../../scripts/Frameworks/PlayerInfo/PlayerInfo\";\r\nimport { Login } from \"../../Proto/proto\";\r\n\r\nexport default class SocketHeartBeatCommon extends SocketHeartBeatBase {\r\n\r\n\r\n    protected initCommon() {\r\n        super.initBase();\r\n    }\r\n\r\n    public getRequestData(): { cmd: number, data: Uint8Array } {\r\n        let msg = Login.HeartBeatRequest.create();\r\n        msg.userId = PlayerInfo.getInstance().getUserID();\r\n        let buffer = Login.HeartBeatRequest.encode(msg).finish();\r\n        return { cmd: Login.C2S_CMD.HeartBeat, data: buffer };\r\n    }\r\n\r\n    public onResponeMessage(msg: { cmd: number, data: Uint8Array }) {\r\n        if (msg.cmd == Login.S2C_CMD.HeartBeat) {\r\n            this.onHeartRespone();\r\n        }\r\n    }\r\n}","\r\nimport SocketMessagePhraserCommon from \"../Common/SocketMessagePhraserCommon\";\r\n\r\nexport default class SocketMessagePhraserBattle extends SocketMessagePhraserCommon {\r\n\r\n    public static create(): SocketMessagePhraserBattle {\r\n        let instance = new SocketMessagePhraserBattle;\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    protected init() {\r\n        super.initCommon();\r\n    }\r\n}","\r\nimport SocketMessagePhraserCommon from \"../Common/SocketMessagePhraserCommon\";\r\n\r\nexport default class SocketMessagePhraserChat extends SocketMessagePhraserCommon {\r\n\r\n    public static create(): SocketMessagePhraserChat {\r\n        let instance = new SocketMessagePhraserChat;\r\n        instance.init();\r\n        return instance;\r\n    }\r\n\r\n    protected init() {\r\n        super.initCommon();\r\n    }\r\n}","\r\n\r\nimport SocketMessagePhraserBase from \"../../../../../../scripts/Frameworks/Network/Socket/SocketMessagePhraser/Base/SocketMessagePhraserBase\";\r\nimport { Login } from \"../../Proto/proto\";\r\n\r\nconst CMD_LENGTH = 4;\t//协议号长度\r\n\r\nexport default class SocketMessagePhraserCommon extends SocketMessagePhraserBase {\r\n\r\n    protected initCommon() {\r\n        super.initBase();\r\n    }\r\n\r\n    public openInfoToMsg(openInfo: any): any {\r\n        let msg = { cmd: Login.S2C_CMD.Open, data: openInfo };\r\n        return msg;\r\n    }\r\n\r\n    public bufferToMsg(recvBuf: ArrayBuffer): { cmd: number, data: Uint8Array } {\r\n        let u8Array = new Uint8Array(recvBuf);\r\n        let recvView = new DataView(u8Array.buffer);\r\n        let cmd = recvView.getInt32(0);\r\n        let buffer = recvBuf.slice(CMD_LENGTH, recvBuf.byteLength);\r\n        let data = new Uint8Array(buffer);\r\n        let msg = { cmd: cmd, data: data };\r\n        return msg;\r\n    }\r\n\r\n    public msgToBuffer(msg: { cmd: number, data: Uint8Array }): ArrayBuffer {\r\n        let dataLength = msg.data.byteLength + CMD_LENGTH;\r\n        let binary: Uint8Array = new Uint8Array(dataLength);\r\n        binary.set(msg.data, CMD_LENGTH);\r\n        var dataView = new DataView(binary.buffer);\r\n        dataView.setUint32(0, msg.cmd);\r\n        return dataView.buffer;\r\n    }\r\n\r\n    public errorInfoToMsg(errorInfo: any) {\r\n        let msg = { cmd: Login.S2C_CMD.Error, data: errorInfo };\r\n        return msg;\r\n    }\r\n\r\n    public closedInfoToMsg(closedInfo: any) {\r\n        let msg = { cmd: Login.S2C_CMD.Closed, data: closedInfo };\r\n        return msg;\r\n    }\r\n}","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.Battle = (function() {\n\n    /**\n     * Namespace Battle.\n     * @exports Battle\n     * @namespace\n     */\n    var Battle = {};\n\n    /**\n     * C2S_CMD enum.\n     * @name Battle.C2S_CMD\n     * @enum {string}\n     * @property {number} Test=10001 Test value\n     */\n    Battle.C2S_CMD = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[10001] = \"Test\"] = 10001;\n        return values;\n    })();\n\n    /**\n     * S2C_CMD enum.\n     * @name Battle.S2C_CMD\n     * @enum {string}\n     * @property {number} Test=20001 Test value\n     */\n    Battle.S2C_CMD = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[20001] = \"Test\"] = 20001;\n        return values;\n    })();\n\n    Battle.Person = (function() {\n\n        /**\n         * Properties of a Person.\n         * @memberof Battle\n         * @interface IPerson\n         * @property {string|null} [name] Person name\n         * @property {number|null} [id] Person id\n         * @property {string|null} [email] Person email\n         */\n\n        /**\n         * Constructs a new Person.\n         * @memberof Battle\n         * @classdesc Represents a Person.\n         * @implements IPerson\n         * @constructor\n         * @param {Battle.IPerson=} [properties] Properties to set\n         */\n        function Person(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Person name.\n         * @member {string} name\n         * @memberof Battle.Person\n         * @instance\n         */\n        Person.prototype.name = \"\";\n\n        /**\n         * Person id.\n         * @member {number} id\n         * @memberof Battle.Person\n         * @instance\n         */\n        Person.prototype.id = 0;\n\n        /**\n         * Person email.\n         * @member {string} email\n         * @memberof Battle.Person\n         * @instance\n         */\n        Person.prototype.email = \"\";\n\n        /**\n         * Creates a new Person instance using the specified properties.\n         * @function create\n         * @memberof Battle.Person\n         * @static\n         * @param {Battle.IPerson=} [properties] Properties to set\n         * @returns {Battle.Person} Person instance\n         */\n        Person.create = function create(properties) {\n            return new Person(properties);\n        };\n\n        /**\n         * Encodes the specified Person message. Does not implicitly {@link Battle.Person.verify|verify} messages.\n         * @function encode\n         * @memberof Battle.Person\n         * @static\n         * @param {Battle.IPerson} message Person message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Person.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);\n            if (message.email != null && message.hasOwnProperty(\"email\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Person message, length delimited. Does not implicitly {@link Battle.Person.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Battle.Person\n         * @static\n         * @param {Battle.IPerson} message Person message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Person.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Person message from the specified reader or buffer.\n         * @function decode\n         * @memberof Battle.Person\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Battle.Person} Person\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Person.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Battle.Person();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.id = reader.int32();\n                    break;\n                case 3:\n                    message.email = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Person message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Battle.Person\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Battle.Person} Person\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Person.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Person message.\n         * @function verify\n         * @memberof Battle.Person\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Person.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isInteger(message.id))\n                    return \"id: integer expected\";\n            if (message.email != null && message.hasOwnProperty(\"email\"))\n                if (!$util.isString(message.email))\n                    return \"email: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a Person message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Battle.Person\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Battle.Person} Person\n         */\n        Person.fromObject = function fromObject(object) {\n            if (object instanceof $root.Battle.Person)\n                return object;\n            var message = new $root.Battle.Person();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.id != null)\n                message.id = object.id | 0;\n            if (object.email != null)\n                message.email = String(object.email);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Person message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Battle.Person\n         * @static\n         * @param {Battle.Person} message Person\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Person.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.name = \"\";\n                object.id = 0;\n                object.email = \"\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.email != null && message.hasOwnProperty(\"email\"))\n                object.email = message.email;\n            return object;\n        };\n\n        /**\n         * Converts this Person to JSON.\n         * @function toJSON\n         * @memberof Battle.Person\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Person.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Person;\n    })();\n\n    return Battle;\n})();\n\n$root.Chat = (function() {\n\n    /**\n     * Namespace Chat.\n     * @exports Chat\n     * @namespace\n     */\n    var Chat = {};\n\n    /**\n     * C2S_CMD enum.\n     * @name Chat.C2S_CMD\n     * @enum {string}\n     * @property {number} Message=10001 Message value\n     */\n    Chat.C2S_CMD = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[10001] = \"Message\"] = 10001;\n        return values;\n    })();\n\n    /**\n     * S2C_CMD enum.\n     * @name Chat.S2C_CMD\n     * @enum {string}\n     * @property {number} Message=20001 Message value\n     */\n    Chat.S2C_CMD = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[20001] = \"Message\"] = 20001;\n        return values;\n    })();\n\n    Chat.Message = (function() {\n\n        /**\n         * Properties of a Message.\n         * @memberof Chat\n         * @interface IMessage\n         * @property {string|null} [word] Message word\n         * @property {number|null} [timestamp] Message timestamp\n         */\n\n        /**\n         * Constructs a new Message.\n         * @memberof Chat\n         * @classdesc Represents a Message.\n         * @implements IMessage\n         * @constructor\n         * @param {Chat.IMessage=} [properties] Properties to set\n         */\n        function Message(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Message word.\n         * @member {string} word\n         * @memberof Chat.Message\n         * @instance\n         */\n        Message.prototype.word = \"\";\n\n        /**\n         * Message timestamp.\n         * @member {number} timestamp\n         * @memberof Chat.Message\n         * @instance\n         */\n        Message.prototype.timestamp = 0;\n\n        /**\n         * Creates a new Message instance using the specified properties.\n         * @function create\n         * @memberof Chat.Message\n         * @static\n         * @param {Chat.IMessage=} [properties] Properties to set\n         * @returns {Chat.Message} Message instance\n         */\n        Message.create = function create(properties) {\n            return new Message(properties);\n        };\n\n        /**\n         * Encodes the specified Message message. Does not implicitly {@link Chat.Message.verify|verify} messages.\n         * @function encode\n         * @memberof Chat.Message\n         * @static\n         * @param {Chat.IMessage} message Message message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Message.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.word != null && message.hasOwnProperty(\"word\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.word);\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.timestamp);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Message message, length delimited. Does not implicitly {@link Chat.Message.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Chat.Message\n         * @static\n         * @param {Chat.IMessage} message Message message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Message.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Message message from the specified reader or buffer.\n         * @function decode\n         * @memberof Chat.Message\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Chat.Message} Message\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Message.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Chat.Message();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.word = reader.string();\n                    break;\n                case 2:\n                    message.timestamp = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Message message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Chat.Message\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Chat.Message} Message\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Message.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Message message.\n         * @function verify\n         * @memberof Chat.Message\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Message.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.word != null && message.hasOwnProperty(\"word\"))\n                if (!$util.isString(message.word))\n                    return \"word: string expected\";\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                if (!$util.isInteger(message.timestamp))\n                    return \"timestamp: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a Message message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Chat.Message\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Chat.Message} Message\n         */\n        Message.fromObject = function fromObject(object) {\n            if (object instanceof $root.Chat.Message)\n                return object;\n            var message = new $root.Chat.Message();\n            if (object.word != null)\n                message.word = String(object.word);\n            if (object.timestamp != null)\n                message.timestamp = object.timestamp | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Message message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Chat.Message\n         * @static\n         * @param {Chat.Message} message Message\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Message.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.word = \"\";\n                object.timestamp = 0;\n            }\n            if (message.word != null && message.hasOwnProperty(\"word\"))\n                object.word = message.word;\n            if (message.timestamp != null && message.hasOwnProperty(\"timestamp\"))\n                object.timestamp = message.timestamp;\n            return object;\n        };\n\n        /**\n         * Converts this Message to JSON.\n         * @function toJSON\n         * @memberof Chat.Message\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Message.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Message;\n    })();\n\n    Chat.MessageRequest = (function() {\n\n        /**\n         * Properties of a MessageRequest.\n         * @memberof Chat\n         * @interface IMessageRequest\n         * @property {string|null} [senderId] MessageRequest senderId\n         * @property {string|null} [receiverId] MessageRequest receiverId\n         * @property {Chat.IMessage|null} [message] MessageRequest message\n         */\n\n        /**\n         * Constructs a new MessageRequest.\n         * @memberof Chat\n         * @classdesc Represents a MessageRequest.\n         * @implements IMessageRequest\n         * @constructor\n         * @param {Chat.IMessageRequest=} [properties] Properties to set\n         */\n        function MessageRequest(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MessageRequest senderId.\n         * @member {string} senderId\n         * @memberof Chat.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.senderId = \"\";\n\n        /**\n         * MessageRequest receiverId.\n         * @member {string} receiverId\n         * @memberof Chat.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.receiverId = \"\";\n\n        /**\n         * MessageRequest message.\n         * @member {Chat.IMessage|null|undefined} message\n         * @memberof Chat.MessageRequest\n         * @instance\n         */\n        MessageRequest.prototype.message = null;\n\n        /**\n         * Creates a new MessageRequest instance using the specified properties.\n         * @function create\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {Chat.IMessageRequest=} [properties] Properties to set\n         * @returns {Chat.MessageRequest} MessageRequest instance\n         */\n        MessageRequest.create = function create(properties) {\n            return new MessageRequest(properties);\n        };\n\n        /**\n         * Encodes the specified MessageRequest message. Does not implicitly {@link Chat.MessageRequest.verify|verify} messages.\n         * @function encode\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {Chat.IMessageRequest} message MessageRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageRequest.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.senderId != null && message.hasOwnProperty(\"senderId\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderId);\n            if (message.receiverId != null && message.hasOwnProperty(\"receiverId\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.receiverId);\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                $root.Chat.Message.encode(message.message, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified MessageRequest message, length delimited. Does not implicitly {@link Chat.MessageRequest.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {Chat.IMessageRequest} message MessageRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageRequest.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a MessageRequest message from the specified reader or buffer.\n         * @function decode\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Chat.MessageRequest} MessageRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRequest.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Chat.MessageRequest();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.senderId = reader.string();\n                    break;\n                case 2:\n                    message.receiverId = reader.string();\n                    break;\n                case 3:\n                    message.message = $root.Chat.Message.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a MessageRequest message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Chat.MessageRequest} MessageRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRequest.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a MessageRequest message.\n         * @function verify\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        MessageRequest.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.senderId != null && message.hasOwnProperty(\"senderId\"))\n                if (!$util.isString(message.senderId))\n                    return \"senderId: string expected\";\n            if (message.receiverId != null && message.hasOwnProperty(\"receiverId\"))\n                if (!$util.isString(message.receiverId))\n                    return \"receiverId: string expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\")) {\n                var error = $root.Chat.Message.verify(message.message);\n                if (error)\n                    return \"message.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a MessageRequest message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Chat.MessageRequest} MessageRequest\n         */\n        MessageRequest.fromObject = function fromObject(object) {\n            if (object instanceof $root.Chat.MessageRequest)\n                return object;\n            var message = new $root.Chat.MessageRequest();\n            if (object.senderId != null)\n                message.senderId = String(object.senderId);\n            if (object.receiverId != null)\n                message.receiverId = String(object.receiverId);\n            if (object.message != null) {\n                if (typeof object.message !== \"object\")\n                    throw TypeError(\".Chat.MessageRequest.message: object expected\");\n                message.message = $root.Chat.Message.fromObject(object.message);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a MessageRequest message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Chat.MessageRequest\n         * @static\n         * @param {Chat.MessageRequest} message MessageRequest\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        MessageRequest.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.senderId = \"\";\n                object.receiverId = \"\";\n                object.message = null;\n            }\n            if (message.senderId != null && message.hasOwnProperty(\"senderId\"))\n                object.senderId = message.senderId;\n            if (message.receiverId != null && message.hasOwnProperty(\"receiverId\"))\n                object.receiverId = message.receiverId;\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = $root.Chat.Message.toObject(message.message, options);\n            return object;\n        };\n\n        /**\n         * Converts this MessageRequest to JSON.\n         * @function toJSON\n         * @memberof Chat.MessageRequest\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        MessageRequest.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return MessageRequest;\n    })();\n\n    /**\n     * MessageErrorCode enum.\n     * @name Chat.MessageErrorCode\n     * @enum {string}\n     * @property {number} Succeed=0 Succeed value\n     * @property {number} Failed=1 Failed value\n     */\n    Chat.MessageErrorCode = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Succeed\"] = 0;\n        values[valuesById[1] = \"Failed\"] = 1;\n        return values;\n    })();\n\n    Chat.MessageRespone = (function() {\n\n        /**\n         * Properties of a MessageRespone.\n         * @memberof Chat\n         * @interface IMessageRespone\n         * @property {string|null} [senderId] MessageRespone senderId\n         * @property {string|null} [receiverId] MessageRespone receiverId\n         * @property {Chat.IMessage|null} [message] MessageRespone message\n         * @property {number|null} [result] MessageRespone result\n         */\n\n        /**\n         * Constructs a new MessageRespone.\n         * @memberof Chat\n         * @classdesc Represents a MessageRespone.\n         * @implements IMessageRespone\n         * @constructor\n         * @param {Chat.IMessageRespone=} [properties] Properties to set\n         */\n        function MessageRespone(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MessageRespone senderId.\n         * @member {string} senderId\n         * @memberof Chat.MessageRespone\n         * @instance\n         */\n        MessageRespone.prototype.senderId = \"\";\n\n        /**\n         * MessageRespone receiverId.\n         * @member {string} receiverId\n         * @memberof Chat.MessageRespone\n         * @instance\n         */\n        MessageRespone.prototype.receiverId = \"\";\n\n        /**\n         * MessageRespone message.\n         * @member {Chat.IMessage|null|undefined} message\n         * @memberof Chat.MessageRespone\n         * @instance\n         */\n        MessageRespone.prototype.message = null;\n\n        /**\n         * MessageRespone result.\n         * @member {number} result\n         * @memberof Chat.MessageRespone\n         * @instance\n         */\n        MessageRespone.prototype.result = 0;\n\n        /**\n         * Creates a new MessageRespone instance using the specified properties.\n         * @function create\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {Chat.IMessageRespone=} [properties] Properties to set\n         * @returns {Chat.MessageRespone} MessageRespone instance\n         */\n        MessageRespone.create = function create(properties) {\n            return new MessageRespone(properties);\n        };\n\n        /**\n         * Encodes the specified MessageRespone message. Does not implicitly {@link Chat.MessageRespone.verify|verify} messages.\n         * @function encode\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {Chat.IMessageRespone} message MessageRespone message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageRespone.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.senderId != null && message.hasOwnProperty(\"senderId\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.senderId);\n            if (message.receiverId != null && message.hasOwnProperty(\"receiverId\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.receiverId);\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                $root.Chat.Message.encode(message.message, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.result);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified MessageRespone message, length delimited. Does not implicitly {@link Chat.MessageRespone.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {Chat.IMessageRespone} message MessageRespone message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MessageRespone.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a MessageRespone message from the specified reader or buffer.\n         * @function decode\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Chat.MessageRespone} MessageRespone\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRespone.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Chat.MessageRespone();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.senderId = reader.string();\n                    break;\n                case 2:\n                    message.receiverId = reader.string();\n                    break;\n                case 3:\n                    message.message = $root.Chat.Message.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.result = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a MessageRespone message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Chat.MessageRespone} MessageRespone\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRespone.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a MessageRespone message.\n         * @function verify\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        MessageRespone.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.senderId != null && message.hasOwnProperty(\"senderId\"))\n                if (!$util.isString(message.senderId))\n                    return \"senderId: string expected\";\n            if (message.receiverId != null && message.hasOwnProperty(\"receiverId\"))\n                if (!$util.isString(message.receiverId))\n                    return \"receiverId: string expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\")) {\n                var error = $root.Chat.Message.verify(message.message);\n                if (error)\n                    return \"message.\" + error;\n            }\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                if (!$util.isInteger(message.result))\n                    return \"result: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a MessageRespone message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Chat.MessageRespone} MessageRespone\n         */\n        MessageRespone.fromObject = function fromObject(object) {\n            if (object instanceof $root.Chat.MessageRespone)\n                return object;\n            var message = new $root.Chat.MessageRespone();\n            if (object.senderId != null)\n                message.senderId = String(object.senderId);\n            if (object.receiverId != null)\n                message.receiverId = String(object.receiverId);\n            if (object.message != null) {\n                if (typeof object.message !== \"object\")\n                    throw TypeError(\".Chat.MessageRespone.message: object expected\");\n                message.message = $root.Chat.Message.fromObject(object.message);\n            }\n            if (object.result != null)\n                message.result = object.result | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a MessageRespone message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Chat.MessageRespone\n         * @static\n         * @param {Chat.MessageRespone} message MessageRespone\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        MessageRespone.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.senderId = \"\";\n                object.receiverId = \"\";\n                object.message = null;\n                object.result = 0;\n            }\n            if (message.senderId != null && message.hasOwnProperty(\"senderId\"))\n                object.senderId = message.senderId;\n            if (message.receiverId != null && message.hasOwnProperty(\"receiverId\"))\n                object.receiverId = message.receiverId;\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = $root.Chat.Message.toObject(message.message, options);\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                object.result = message.result;\n            return object;\n        };\n\n        /**\n         * Converts this MessageRespone to JSON.\n         * @function toJSON\n         * @memberof Chat.MessageRespone\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        MessageRespone.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return MessageRespone;\n    })();\n\n    return Chat;\n})();\n\n$root.Login = (function() {\n\n    /**\n     * Namespace Login.\n     * @exports Login\n     * @namespace\n     */\n    var Login = {};\n\n    /**\n     * C2S_CMD enum.\n     * @name Login.C2S_CMD\n     * @enum {string}\n     * @property {number} Open=1001 Open value\n     * @property {number} Error=1002 Error value\n     * @property {number} Close=1003 Close value\n     * @property {number} Login=1004 Login value\n     * @property {number} HeartBeat=1005 HeartBeat value\n     */\n    Login.C2S_CMD = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[1001] = \"Open\"] = 1001;\n        values[valuesById[1002] = \"Error\"] = 1002;\n        values[valuesById[1003] = \"Close\"] = 1003;\n        values[valuesById[1004] = \"Login\"] = 1004;\n        values[valuesById[1005] = \"HeartBeat\"] = 1005;\n        return values;\n    })();\n\n    /**\n     * S2C_CMD enum.\n     * @name Login.S2C_CMD\n     * @enum {string}\n     * @property {number} Open=2001 Open value\n     * @property {number} Error=2002 Error value\n     * @property {number} Closed=2003 Closed value\n     * @property {number} Login=2004 Login value\n     * @property {number} HeartBeat=2005 HeartBeat value\n     */\n    Login.S2C_CMD = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[2001] = \"Open\"] = 2001;\n        values[valuesById[2002] = \"Error\"] = 2002;\n        values[valuesById[2003] = \"Closed\"] = 2003;\n        values[valuesById[2004] = \"Login\"] = 2004;\n        values[valuesById[2005] = \"HeartBeat\"] = 2005;\n        return values;\n    })();\n\n    Login.LoginRequest = (function() {\n\n        /**\n         * Properties of a LoginRequest.\n         * @memberof Login\n         * @interface ILoginRequest\n         * @property {string|null} [userId] LoginRequest userId\n         */\n\n        /**\n         * Constructs a new LoginRequest.\n         * @memberof Login\n         * @classdesc Represents a LoginRequest.\n         * @implements ILoginRequest\n         * @constructor\n         * @param {Login.ILoginRequest=} [properties] Properties to set\n         */\n        function LoginRequest(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LoginRequest userId.\n         * @member {string} userId\n         * @memberof Login.LoginRequest\n         * @instance\n         */\n        LoginRequest.prototype.userId = \"\";\n\n        /**\n         * Creates a new LoginRequest instance using the specified properties.\n         * @function create\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {Login.ILoginRequest=} [properties] Properties to set\n         * @returns {Login.LoginRequest} LoginRequest instance\n         */\n        LoginRequest.create = function create(properties) {\n            return new LoginRequest(properties);\n        };\n\n        /**\n         * Encodes the specified LoginRequest message. Does not implicitly {@link Login.LoginRequest.verify|verify} messages.\n         * @function encode\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {Login.ILoginRequest} message LoginRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginRequest.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LoginRequest message, length delimited. Does not implicitly {@link Login.LoginRequest.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {Login.ILoginRequest} message LoginRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginRequest.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LoginRequest message from the specified reader or buffer.\n         * @function decode\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Login.LoginRequest} LoginRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginRequest.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Login.LoginRequest();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LoginRequest message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Login.LoginRequest} LoginRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginRequest.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LoginRequest message.\n         * @function verify\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LoginRequest.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                if (!$util.isString(message.userId))\n                    return \"userId: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LoginRequest message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Login.LoginRequest} LoginRequest\n         */\n        LoginRequest.fromObject = function fromObject(object) {\n            if (object instanceof $root.Login.LoginRequest)\n                return object;\n            var message = new $root.Login.LoginRequest();\n            if (object.userId != null)\n                message.userId = String(object.userId);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LoginRequest message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Login.LoginRequest\n         * @static\n         * @param {Login.LoginRequest} message LoginRequest\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LoginRequest.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults)\n                object.userId = \"\";\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                object.userId = message.userId;\n            return object;\n        };\n\n        /**\n         * Converts this LoginRequest to JSON.\n         * @function toJSON\n         * @memberof Login.LoginRequest\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LoginRequest.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LoginRequest;\n    })();\n\n    /**\n     * LoginErrorCode enum.\n     * @name Login.LoginErrorCode\n     * @enum {string}\n     * @property {number} Succeed=0 Succeed value\n     * @property {number} Failed=1 Failed value\n     */\n    Login.LoginErrorCode = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Succeed\"] = 0;\n        values[valuesById[1] = \"Failed\"] = 1;\n        return values;\n    })();\n\n    Login.LoginRespone = (function() {\n\n        /**\n         * Properties of a LoginRespone.\n         * @memberof Login\n         * @interface ILoginRespone\n         * @property {string|null} [userId] LoginRespone userId\n         * @property {number|null} [result] LoginRespone result\n         */\n\n        /**\n         * Constructs a new LoginRespone.\n         * @memberof Login\n         * @classdesc Represents a LoginRespone.\n         * @implements ILoginRespone\n         * @constructor\n         * @param {Login.ILoginRespone=} [properties] Properties to set\n         */\n        function LoginRespone(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LoginRespone userId.\n         * @member {string} userId\n         * @memberof Login.LoginRespone\n         * @instance\n         */\n        LoginRespone.prototype.userId = \"\";\n\n        /**\n         * LoginRespone result.\n         * @member {number} result\n         * @memberof Login.LoginRespone\n         * @instance\n         */\n        LoginRespone.prototype.result = 0;\n\n        /**\n         * Creates a new LoginRespone instance using the specified properties.\n         * @function create\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {Login.ILoginRespone=} [properties] Properties to set\n         * @returns {Login.LoginRespone} LoginRespone instance\n         */\n        LoginRespone.create = function create(properties) {\n            return new LoginRespone(properties);\n        };\n\n        /**\n         * Encodes the specified LoginRespone message. Does not implicitly {@link Login.LoginRespone.verify|verify} messages.\n         * @function encode\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {Login.ILoginRespone} message LoginRespone message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginRespone.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LoginRespone message, length delimited. Does not implicitly {@link Login.LoginRespone.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {Login.ILoginRespone} message LoginRespone message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LoginRespone.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LoginRespone message from the specified reader or buffer.\n         * @function decode\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Login.LoginRespone} LoginRespone\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginRespone.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Login.LoginRespone();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.userId = reader.string();\n                    break;\n                case 2:\n                    message.result = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LoginRespone message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Login.LoginRespone} LoginRespone\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LoginRespone.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LoginRespone message.\n         * @function verify\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LoginRespone.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                if (!$util.isString(message.userId))\n                    return \"userId: string expected\";\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                if (!$util.isInteger(message.result))\n                    return \"result: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LoginRespone message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Login.LoginRespone} LoginRespone\n         */\n        LoginRespone.fromObject = function fromObject(object) {\n            if (object instanceof $root.Login.LoginRespone)\n                return object;\n            var message = new $root.Login.LoginRespone();\n            if (object.userId != null)\n                message.userId = String(object.userId);\n            if (object.result != null)\n                message.result = object.result | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LoginRespone message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Login.LoginRespone\n         * @static\n         * @param {Login.LoginRespone} message LoginRespone\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LoginRespone.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.userId = \"\";\n                object.result = 0;\n            }\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                object.userId = message.userId;\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                object.result = message.result;\n            return object;\n        };\n\n        /**\n         * Converts this LoginRespone to JSON.\n         * @function toJSON\n         * @memberof Login.LoginRespone\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LoginRespone.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LoginRespone;\n    })();\n\n    Login.HeartBeatRequest = (function() {\n\n        /**\n         * Properties of a HeartBeatRequest.\n         * @memberof Login\n         * @interface IHeartBeatRequest\n         * @property {string|null} [userId] HeartBeatRequest userId\n         */\n\n        /**\n         * Constructs a new HeartBeatRequest.\n         * @memberof Login\n         * @classdesc Represents a HeartBeatRequest.\n         * @implements IHeartBeatRequest\n         * @constructor\n         * @param {Login.IHeartBeatRequest=} [properties] Properties to set\n         */\n        function HeartBeatRequest(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HeartBeatRequest userId.\n         * @member {string} userId\n         * @memberof Login.HeartBeatRequest\n         * @instance\n         */\n        HeartBeatRequest.prototype.userId = \"\";\n\n        /**\n         * Creates a new HeartBeatRequest instance using the specified properties.\n         * @function create\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {Login.IHeartBeatRequest=} [properties] Properties to set\n         * @returns {Login.HeartBeatRequest} HeartBeatRequest instance\n         */\n        HeartBeatRequest.create = function create(properties) {\n            return new HeartBeatRequest(properties);\n        };\n\n        /**\n         * Encodes the specified HeartBeatRequest message. Does not implicitly {@link Login.HeartBeatRequest.verify|verify} messages.\n         * @function encode\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {Login.IHeartBeatRequest} message HeartBeatRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartBeatRequest.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HeartBeatRequest message, length delimited. Does not implicitly {@link Login.HeartBeatRequest.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {Login.IHeartBeatRequest} message HeartBeatRequest message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartBeatRequest.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HeartBeatRequest message from the specified reader or buffer.\n         * @function decode\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Login.HeartBeatRequest} HeartBeatRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartBeatRequest.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Login.HeartBeatRequest();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HeartBeatRequest message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Login.HeartBeatRequest} HeartBeatRequest\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartBeatRequest.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HeartBeatRequest message.\n         * @function verify\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HeartBeatRequest.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                if (!$util.isString(message.userId))\n                    return \"userId: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a HeartBeatRequest message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Login.HeartBeatRequest} HeartBeatRequest\n         */\n        HeartBeatRequest.fromObject = function fromObject(object) {\n            if (object instanceof $root.Login.HeartBeatRequest)\n                return object;\n            var message = new $root.Login.HeartBeatRequest();\n            if (object.userId != null)\n                message.userId = String(object.userId);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a HeartBeatRequest message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Login.HeartBeatRequest\n         * @static\n         * @param {Login.HeartBeatRequest} message HeartBeatRequest\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HeartBeatRequest.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults)\n                object.userId = \"\";\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                object.userId = message.userId;\n            return object;\n        };\n\n        /**\n         * Converts this HeartBeatRequest to JSON.\n         * @function toJSON\n         * @memberof Login.HeartBeatRequest\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HeartBeatRequest.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return HeartBeatRequest;\n    })();\n\n    /**\n     * HeartBeatErrorCode enum.\n     * @name Login.HeartBeatErrorCode\n     * @enum {string}\n     * @property {number} Succeed=0 Succeed value\n     * @property {number} Failed=1 Failed value\n     */\n    Login.HeartBeatErrorCode = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Succeed\"] = 0;\n        values[valuesById[1] = \"Failed\"] = 1;\n        return values;\n    })();\n\n    Login.HeartBeatRespone = (function() {\n\n        /**\n         * Properties of a HeartBeatRespone.\n         * @memberof Login\n         * @interface IHeartBeatRespone\n         * @property {string|null} [userId] HeartBeatRespone userId\n         * @property {number|null} [result] HeartBeatRespone result\n         */\n\n        /**\n         * Constructs a new HeartBeatRespone.\n         * @memberof Login\n         * @classdesc Represents a HeartBeatRespone.\n         * @implements IHeartBeatRespone\n         * @constructor\n         * @param {Login.IHeartBeatRespone=} [properties] Properties to set\n         */\n        function HeartBeatRespone(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HeartBeatRespone userId.\n         * @member {string} userId\n         * @memberof Login.HeartBeatRespone\n         * @instance\n         */\n        HeartBeatRespone.prototype.userId = \"\";\n\n        /**\n         * HeartBeatRespone result.\n         * @member {number} result\n         * @memberof Login.HeartBeatRespone\n         * @instance\n         */\n        HeartBeatRespone.prototype.result = 0;\n\n        /**\n         * Creates a new HeartBeatRespone instance using the specified properties.\n         * @function create\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {Login.IHeartBeatRespone=} [properties] Properties to set\n         * @returns {Login.HeartBeatRespone} HeartBeatRespone instance\n         */\n        HeartBeatRespone.create = function create(properties) {\n            return new HeartBeatRespone(properties);\n        };\n\n        /**\n         * Encodes the specified HeartBeatRespone message. Does not implicitly {@link Login.HeartBeatRespone.verify|verify} messages.\n         * @function encode\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {Login.IHeartBeatRespone} message HeartBeatRespone message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartBeatRespone.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HeartBeatRespone message, length delimited. Does not implicitly {@link Login.HeartBeatRespone.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {Login.IHeartBeatRespone} message HeartBeatRespone message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HeartBeatRespone.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HeartBeatRespone message from the specified reader or buffer.\n         * @function decode\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Login.HeartBeatRespone} HeartBeatRespone\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartBeatRespone.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Login.HeartBeatRespone();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.userId = reader.string();\n                    break;\n                case 2:\n                    message.result = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HeartBeatRespone message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Login.HeartBeatRespone} HeartBeatRespone\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HeartBeatRespone.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HeartBeatRespone message.\n         * @function verify\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HeartBeatRespone.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                if (!$util.isString(message.userId))\n                    return \"userId: string expected\";\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                if (!$util.isInteger(message.result))\n                    return \"result: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a HeartBeatRespone message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Login.HeartBeatRespone} HeartBeatRespone\n         */\n        HeartBeatRespone.fromObject = function fromObject(object) {\n            if (object instanceof $root.Login.HeartBeatRespone)\n                return object;\n            var message = new $root.Login.HeartBeatRespone();\n            if (object.userId != null)\n                message.userId = String(object.userId);\n            if (object.result != null)\n                message.result = object.result | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a HeartBeatRespone message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Login.HeartBeatRespone\n         * @static\n         * @param {Login.HeartBeatRespone} message HeartBeatRespone\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HeartBeatRespone.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.userId = \"\";\n                object.result = 0;\n            }\n            if (message.userId != null && message.hasOwnProperty(\"userId\"))\n                object.userId = message.userId;\n            if (message.result != null && message.hasOwnProperty(\"result\"))\n                object.result = message.result;\n            return object;\n        };\n\n        /**\n         * Converts this HeartBeatRespone to JSON.\n         * @function toJSON\n         * @memberof Login.HeartBeatRespone\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HeartBeatRespone.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return HeartBeatRespone;\n    })();\n\n    return Login;\n})();\n\nmodule.exports = $root;\n"],"file":"index.js"}